

--- FILE: src/App.jsx ---

import React, { useState, useEffect } from 'react';
import Sidebar from './components/Sidebar';
import ChatList from './components/ChatList';
import ChatArea from './components/ChatArea';
import ConfigModal from './components/ConfigModal';
import ConnectModal from './components/ConnectModal';
import BriefingModal from './components/BriefingModal';
import HistoryView from './components/HistoryView';
import CRMView from './components/CRMView';
// LandingPage is now handled by src/landing.jsx and index.html
import { useStore } from './store/useStore';
import WhatsAppService from './services/whatsapp';
import { useKnowledgeLoop } from './hooks/useKnowledgeLoop';

const App = () => {
  useKnowledgeLoop(); // AURA v11: Dynamic Knowledge Loop
  const { isConnected, setIsConnected, currentView, briefing, setChats, activeChat, setActiveChat } = useStore();
  const [isConfigOpen, setIsConfigOpen] = useState(false);
  const [isConnectOpen, setIsConnectOpen] = useState(false);
  const [isBriefingOpen, setIsBriefingOpen] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  // AUTH: Check if user is authenticated
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  // LANDING: Track if user clicked "J√° sou Cliente" to show login
  const [showLogin, setShowLogin] = useState(false);

  // AUTH: Check localStorage for authentication token
  useEffect(() => {
    const checkAuth = () => {
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setIsAuthenticated(false);
        return;
      }

      try {
        // Simple validation: Decode token and check prefix
        const decoded = atob(token);
        if (decoded.startsWith('authenticated:')) {
          setIsAuthenticated(true);
        } else {
          console.warn('AURA: Invalid token format, logging out');
          localStorage.removeItem('auth_token');
          setIsAuthenticated(false);
        }
      } catch (e) {
        console.error('AURA: Token validation error', e);
        localStorage.removeItem('auth_token');
        setIsAuthenticated(false);
      }
    };

    checkAuth();
    // Also listen for storage changes (multi-tab logout support)
    window.addEventListener('storage', checkAuth);
    return () => window.removeEventListener('storage', checkAuth);
  }, []);

  // LEAD PROCESSING: Check for pending leads from Landing Page
  useEffect(() => {
    if (isAuthenticated) {
      const pendingLead = localStorage.getItem('aura_pending_lead');
      if (pendingLead) {
        try {
          const leadData = JSON.parse(pendingLead);
          console.log('AURA: Processing pending lead', leadData);
          useStore.getState().addLead(leadData);
          useStore.getState().switchView('crm'); // Go to CRM to see the new lead
          localStorage.removeItem('aura_pending_lead');
        } catch (e) {
          console.error('AURA: Failed to process pending lead', e);
        }
      }
    }
  }, [isAuthenticated]);

  // Handle external modal triggers (from Hub/Settings)
  useEffect(() => {
    const handleOpenBriefing = () => setIsBriefingOpen(true);
    const handleOpenConnect = () => setIsConnectOpen(true);

    window.addEventListener('open-briefing', handleOpenBriefing);
    window.addEventListener('open-connect', handleOpenConnect);

    return () => {
      window.removeEventListener('open-briefing', handleOpenBriefing);
      window.removeEventListener('open-connect', handleOpenConnect);
    };
  }, []);


  // Check WhatsApp connection status (only when authenticated)
  useEffect(() => {
    if (!isAuthenticated) return;

    const checkConn = async () => {
      const status = await WhatsAppService.checkConnection();
      const open = status === 'open';
      setIsConnected(open);
      if (open) {
        const data = await WhatsAppService.fetchChats();
        if (data && data.length > 0) setChats(data);
      }
    };
    checkConn();
    const itv = setInterval(checkConn, 30000);
    return () => clearInterval(itv);
  }, [setIsConnected, setChats, isAuthenticated]);

  // AUTH: Handle logout
  const handleLogout = () => {
    localStorage.removeItem('auth_token');
    setIsAuthenticated(false);
    window.location.href = '/'; // Redirect to Landing Page
  };

  // AUTH: If not authenticated but user want to login (or direct access), show login screen
  if (!isAuthenticated && !showLogin) {
    // Default to login if accessing /app directly
    console.log('AURA: Rendering Login Screen');
    return <LoginScreen onLogin={() => setIsAuthenticated(true)} />;
  }

  // AUTH: If not authenticated but user wants to login, show login screen
  if (!isAuthenticated && showLogin) {
    console.log('AURA: Rendering Login Screen');
    return <LoginScreen onLogin={() => setIsAuthenticated(true)} />;
  }

  // MAIN APP: User is authenticated
  return (
    <div className={`app-container ${currentView === 'crm' ? 'crm-mode' : ''}`}>
      <Sidebar
        onOpenConfig={() => setIsConfigOpen(true)}
        onOpenConnect={() => setIsConnectOpen(true)}
        onOpenBriefing={() => setIsBriefingOpen(true)}
        onLogout={handleLogout}
        isOpen={isMobileMenuOpen}
        onClose={() => setIsMobileMenuOpen(false)}
      />

      {/* CENTRAL COLUMN: Selective rendering based on view */}
      {currentView === 'history' && <HistoryView />}
      {currentView === 'dashboard' && <ChatList onOpenMenu={() => setIsMobileMenuOpen(true)} />}
      {/* CRM view is full-width, middle column is purposely excluded */}

      <main className={`main-content ${activeChat ? 'mobile-chat-open' : 'mobile-chat-closed'}`}>
        {currentView === 'crm' ? (
          <CRMView />
        ) : currentView === 'dashboard' ? (
          <DashboardView />
        ) : activeChat ? (
          <ChatArea isArchived={currentView === 'history'} onBack={() => setActiveChat(null)} />
        ) : (
          <div className="history-placeholder glass-panel" style={{ flex: 1, margin: '20px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <h2 style={{ color: '#86868b', opacity: 0.5 }}>
              {currentView === 'history' ? 'Selecione uma conversa arquivada' : 'Selecione uma conversa para iniciar'}
            </h2>
          </div>
        )}
      </main>

      <ConfigModal isOpen={isConfigOpen} onClose={() => setIsConfigOpen(false)} />
      <ConnectModal isOpen={isConnectOpen} onClose={() => setIsConnectOpen(false)} />
      <BriefingModal isOpen={isBriefingOpen} onClose={() => setIsBriefingOpen(false)} />
    </div>
  );
};

export default App;


--- FILE: src/components/AudioPlayer.jsx ---

import React, { useState, useEffect } from 'react';
import { Play, Pause, Volume2 } from 'lucide-react';
import WhatsAppService from '../services/whatsapp';

const AudioPlayer = ({ messageKey }) => {
    const [audioUrl, setAudioUrl] = useState(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(false);
    const audioRef = React.useRef(null);

    useEffect(() => {
        const loadAudio = async () => {
            try {
                const base64Data = await WhatsAppService.fetchMediaUrl(messageKey);
                if (base64Data) {
                    setAudioUrl(base64Data);
                } else {
                    setError(true);
                }
            } catch (e) {
                console.error("Audio load error:", e);
                setError(true);
            } finally {
                setLoading(false);
            }
        };

        if (messageKey) {
            loadAudio();
        }
    }, [messageKey]);

    const togglePlay = () => {
        if (!audioRef.current) return;

        if (isPlaying) {
            audioRef.current.pause();
        } else {
            audioRef.current.play();
        }
        setIsPlaying(!isPlaying);
    };

    const handleEnded = () => {
        setIsPlaying(false);
    };

    if (loading) {
        return (
            <div className="audio-player loading">
                <Volume2 size={16} color="#00e5ff" />
                <span style={{ fontSize: '12px', marginLeft: '8px' }}>Carregando √°udio...</span>
            </div>
        );
    }

    if (error || !audioUrl) {
        return (
            <div className="audio-player error">
                <Volume2 size={16} color="#ff5555" />
                <span style={{ fontSize: '12px', marginLeft: '8px' }}>Erro ao carregar √°udio</span>
            </div>
        );
    }

    return (
        <div className="audio-player">
            <button
                onClick={togglePlay}
                className="play-btn"
                style={{
                    background: 'rgba(0, 229, 255, 0.2)',
                    border: '1px solid #00e5ff',
                    borderRadius: '50%',
                    width: '32px',
                    height: '32px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: 'pointer',
                    transition: 'all 0.2s'
                }}
            >
                {isPlaying ? <Pause size={16} color="#00e5ff" /> : <Play size={16} color="#00e5ff" />}
            </button>
            <audio
                ref={audioRef}
                src={audioUrl}
                onEnded={handleEnded}
                style={{ display: 'none' }}
            />
            <span style={{ fontSize: '12px', marginLeft: '8px', color: 'rgba(255,255,255,0.7)' }}>
                {isPlaying ? 'Reproduzindo...' : '√Åudio do cliente'}
            </span>
        </div>
    );
};

export default AudioPlayer;


--- FILE: src/components/BriefingModal.jsx ---

import React, { useState, useEffect } from 'react';
import { X, ArrowRight, Save, Sparkles, Brain, Edit2, Check, RefreshCw, Plus } from 'lucide-react';
import { useStore } from '../store/useStore';

const BriefingModal = ({ isOpen, onClose }) => {
    const { briefing, knowledgeBase, setConfig, setKnowledgeBase } = useStore();
    const [view, setView] = useState('dashboard'); // interview, dashboard
    const [status, setStatus] = useState('idle'); // idle, thinking, showing_analysis
    const [currentQuestion, setCurrentQuestion] = useState("Para come√ßarmos: Qual o nome da sua empresa e o que exatamente voc√™s fazem?");
    const [currentAnswer, setCurrentAnswer] = useState("");
    const [lastAnalysis, setLastAnalysis] = useState("");
    const [editingId, setEditingId] = useState(null);
    const [tempAnswer, setTempAnswer] = useState("");
    const [confirmReset, setConfirmReset] = useState(false);
    const [isResetting, setIsResetting] = useState(false);

    // Start in dashboard view by default
    useEffect(() => {
        if (isOpen) {
            setView('dashboard');
            setStatus('idle');
        }
    }, [isOpen]);

    if (!isOpen) return null;

    const handleNextInterview = async () => {
        if (!currentAnswer.trim()) return;

        setStatus('thinking');
        try {
            const { default: OpenAIService } = await import('../services/openai');

            // 1. Generate strategic analysis for this point
            const analysis = await OpenAIService.analyzeKnowledgePoint(currentQuestion, currentAnswer);
            setLastAnalysis(analysis);

            const newItem = {
                id: Date.now(),
                q: currentQuestion,
                a: currentAnswer,
                analysis
            };

            const currentKB = knowledgeBase || [];
            const newKB = [...currentKB, newItem];
            setKnowledgeBase(newKB);

            // Show analysis before moving on
            setStatus('showing_analysis');
        } catch (e) {
            console.error("AURA: Error in interview step", e);
            setStatus('idle');
        }
    };

    const proceedToNext = async () => {
        setStatus('thinking');
        try {
            const { default: OpenAIService } = await import('../services/openai');
            const nextQ = await OpenAIService.generateNextBriefingQuestion(knowledgeBase);

            if (nextQ.includes("COMPLETE") || knowledgeBase.length >= 10) {
                setStatus('idle');
                setView('dashboard');
                syncBriefingText(knowledgeBase);
            } else {
                setCurrentQuestion(nextQ);
                setCurrentAnswer("");
                setLastAnalysis("");
                setStatus('idle');
            }
        } catch (e) {
            setStatus('idle');
        }
    };

    const syncBriefingText = (kb) => {
        const currentKB = kb || [];
        const text = currentKB.map(h => `[P]: ${h.q}\n[R]: ${h.a}`).join('\n\n');
        setConfig({ briefing: text });
    };

    const handleUpdatePoint = async (id) => {
        const currentKB = knowledgeBase || [];
        const point = currentKB.find(k => k.id === id);
        if (!point) return;

        setStatus('thinking');
        try {
            const { default: OpenAIService } = await import('../services/openai');
            const analysis = await OpenAIService.analyzeKnowledgePoint(point.q, tempAnswer);

            const newKB = currentKB.map(item =>
                item.id === id ? { ...item, a: tempAnswer, analysis } : item
            );

            setKnowledgeBase(newKB);
            syncBriefingText(newKB);
            setEditingId(null);
            setStatus('idle');
        } catch (e) {
            setStatus('idle');
        }
    };

    const safeKB = knowledgeBase || [];
    const hasRawBriefing = briefing && briefing.length > 0 && safeKB.length === 0;

    return (
        <div className="modal-overlay" onClick={onClose} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(10px)', zIndex: 1000, backgroundColor: 'rgba(255,255,255,0.1)' }}>
            <div className="modal-content glass-panel" style={{ width: '95%', maxWidth: '800px', padding: '0', maxHeight: '85vh', overflow: 'hidden', display: 'flex', flexDirection: 'column', background: '#FFFFFF', border: '1px solid rgba(0,0,0,0.05)', boxShadow: '0 30px 60px rgba(0,0,0,0.15)' }} onClick={e => e.stopPropagation()}>

                <div className="briefing-header" style={{
                    padding: '25px 40px',
                    background: '#FFFFFF',
                    borderBottom: '1px solid rgba(0,0,0,0.05)',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center'
                }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '18px' }}>
                        <div style={{ padding: '12px', background: 'rgba(197, 160, 89, 0.1)', borderRadius: '14px' }}>
                            <Brain size={26} color="var(--accent-primary)" />
                        </div>
                        <div>
                            <h2 style={{ color: '#1d1d1f', margin: 0, fontSize: '20px', fontWeight: 'bold' }}>C√©rebro Estrat√©gico AURA</h2>
                            <p style={{ color: '#86868b', margin: 0, fontSize: '11px', textTransform: 'uppercase', letterSpacing: '1px' }}>Treinamento Avan√ßado de Intelig√™ncia</p>
                        </div>
                    </div>
                    <div style={{ display: 'flex', gap: '15px', alignItems: 'center' }}>
                        <button
                            onClick={() => {
                                if (isResetting) return;

                                if (!confirmReset) {
                                    setConfirmReset(true);
                                    return;
                                }

                                // EXECUTE RESET
                                setIsResetting(true);
                                useStore.getState().resetBrain();
                                localStorage.removeItem('aura-storage');

                                // DELAY RELOAD FOR UX & PERSISTENCE
                                setTimeout(() => window.location.reload(), 1500);
                            }}
                            style={{
                                background: isResetting ? '#E5E5E7' : (confirmReset ? '#ff4d4d' : '#FFF5F5'),
                                color: isResetting ? '#86868b' : (confirmReset ? '#FFFFFF' : '#ff4d4d'),
                                border: confirmReset ? 'none' : '1px solid #FFEBEB',
                                padding: '8px 16px',
                                borderRadius: '10px',
                                cursor: isResetting ? 'wait' : 'pointer',
                                fontSize: '11px',
                                fontWeight: 'bold',
                                transition: 'all 0.2s'
                            }}
                        >
                            {isResetting ? "Limpando..." : (confirmReset ? "TEM CERTEZA?" : "Resetar C√©rebro")}
                        </button>
                        <span style={{ fontSize: '9px', color: '#ccc' }}>v12.0-beta</span>
                        <X size={24} color="#1d1d1f" onClick={onClose} style={{ cursor: 'pointer', opacity: 0.3 }} />
                    </div>
                </div>

                <div className="briefing-body" style={{ padding: '40px', overflowY: 'auto', flex: 1, background: '#FDFDFD' }}>

                    {view === 'interview' ? (
                        <div className="interview-flow" style={{ maxWidth: '650px', margin: '20px auto' }}>
                            <div className="question-area" style={{
                                background: '#FFFFFF',
                                padding: '30px', /* REDUCED: Was 45px */
                                borderRadius: '24px',
                                border: '1px solid rgba(197, 160, 89, 0.2)',
                                boxShadow: '0 10px 30px rgba(197, 160, 89, 0.05)'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '15px' }}>
                                    <Sparkles size={14} color="var(--accent-primary)" />
                                    <span style={{ color: 'var(--accent-primary)', fontWeight: 'bold', fontSize: '10px', textTransform: 'uppercase', letterSpacing: '1.5px' }}>Aura Mentor</span>
                                </div>

                                <h3 style={{ margin: '0 0 20px 0', fontSize: '18px', color: '#1d1d1f', lineHeight: '1.4', fontWeight: 'bold' }}>
                                    {status === 'thinking' ? "Gerando Insight..." : currentQuestion}
                                </h3>

                                {status === 'showing_analysis' ? (
                                    <div style={{ animation: 'fadeIn 0.5s ease' }}>
                                        {/* Show Answer (Read Only) */}
                                        <div style={{ marginBottom: '20px', padding: '20px', background: '#F9F9FA', borderRadius: '16px', border: '1px solid #E5E5E7', fontSize: '15px', color: '#1d1d1f' }}>
                                            {currentAnswer}
                                        </div>

                                        {/* Analysis Box - Clean White/Gray (No Beige) */}
                                        <div style={{
                                            background: '#FFFFFF',
                                            border: '1px solid #E5E5E7',
                                            borderRadius: '20px',
                                            padding: '25px',
                                            marginBottom: '30px',
                                            position: 'relative',
                                            boxShadow: '0 4px 20px rgba(0,0,0,0.03)'
                                        }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '10px' }}>
                                                <Sparkles size={16} color="var(--accent-primary)" />
                                                <span style={{ fontSize: '11px', fontWeight: '800', color: 'var(--accent-primary)', textTransform: 'uppercase' }}>Insight Aura</span>
                                            </div>
                                            <p style={{ margin: 0, fontSize: '14px', color: '#4a4a4c', fontStyle: 'italic', lineHeight: '1.6' }}>
                                                "{lastAnalysis}"
                                            </p>
                                        </div>

                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <button
                                                onClick={() => setStatus('idle')} // Go back to editing
                                                style={{ background: 'transparent', border: 'none', color: '#86868b', textDecoration: 'underline', cursor: 'pointer', fontSize: '13px' }}
                                            >
                                                Editar minha resposta
                                            </button>

                                            <button
                                                className="btn-primary"
                                                onClick={proceedToNext}
                                                style={{ padding: '15px 45px', borderRadius: '50px', fontWeight: 'bold' }}
                                            >
                                                Pr√≥xima Pergunta <ArrowRight size={18} />
                                            </button>
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        <div style={{ position: 'relative' }}>
                                            <textarea
                                                autoFocus
                                                value={currentAnswer}
                                                onChange={(e) => setCurrentAnswer(e.target.value)}
                                                placeholder="Sua resposta moldar√° como a IA atende seus clientes..."
                                                style={{
                                                    width: '100%',
                                                    background: '#F9F9FA',
                                                    border: '1px solid #E5E5E7',
                                                    borderRadius: '16px',
                                                    padding: '25px',
                                                    color: '#1d1d1f',
                                                    fontSize: '16px',
                                                    minHeight: '180px',
                                                    lineHeight: '1.6',
                                                    outline: 'none',
                                                    resize: 'none',
                                                    transition: 'border-color 0.2s'
                                                }}
                                                onFocus={e => e.target.style.borderColor = 'var(--accent-primary)'}
                                                onBlur={e => e.target.style.borderColor = '#E5E5E7'}
                                            />
                                            {status === 'thinking' && (
                                                <div style={{ position: 'absolute', inset: 0, background: 'rgba(255,255,255,0.7)', borderRadius: '16px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                                    <RefreshCw className="spin" size={32} color="var(--accent-primary)" />
                                                </div>
                                            )}
                                        </div>
                                        <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: '30px' }}>
                                            <button
                                                className="btn-primary"
                                                onClick={handleNextInterview}
                                                disabled={!currentAnswer.trim() || status === 'thinking'}
                                                style={{ padding: '15px 45px', borderRadius: '50px', fontWeight: 'bold' }}
                                            >
                                                {status === 'thinking' ? "Analisando..." : "Confirmar Vis√£o"} <ArrowRight size={18} />
                                            </button>
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>
                    ) : (
                        <div className="knowledge-dashboard" style={{ maxWidth: '750px', margin: '0 auto' }}>
                            {/* IF NO STRUCTURED DATA, BUT RAW BRIEFING EXISTS */}
                            {safeKB.length === 0 && hasRawBriefing && (
                                <div style={{ marginBottom: '30px', padding: '20px', background: '#FFF9E6', border: '1px solid #FFE4A3', borderRadius: '16px' }}>
                                    <h4 style={{ margin: '0 0 10px 0', color: '#977A23' }}>Conhecimento Bruto Detectado</h4>
                                    <p style={{ margin: 0, fontSize: '13px', color: '#977A23', opacity: 0.8 }}>
                                        Voc√™ possui dados de briefing inseridos manualmente. Eles est√£o ativos, mas n√£o visualiz√°veis em cards estruturados.
                                        Para criar uma estrutura organizada, inicie a entrevista abaixo.
                                    </p>
                                </div>
                            )}

                            {/* MANAGER PHONE SETTING - NEW LOCATION */}
                            <div className="manager-phone-settings" style={{
                                marginBottom: '30px',
                                padding: '24px',
                                background: '#FFFFFF',
                                border: '1px solid rgba(197, 160, 89, 0.3)',
                                borderRadius: '20px',
                                boxShadow: '0 4px 15px rgba(0,0,0,0.03)'
                            }}>
                                <label style={{ display: 'flex', alignItems: 'center', gap: '10px', color: '#1d1d1f', fontWeight: '800', fontSize: '15px', marginBottom: '8px' }}>
                                    <RefreshCw size={18} color="var(--accent-primary)" /> Telefone do Gestor (AURA Loop)
                                </label>
                                <p style={{ margin: '0 0 15px 0', fontSize: '12px', color: '#86868b' }}>
                                    Defina o WhatsApp para onde a AURA enviar√° d√∫vidas t√°ticas quando n√£o souber responder um cliente.
                                </p>
                                <div style={{ position: 'relative' }}>
                                    <input
                                        type="text"
                                        value={useStore.getState().managerPhone}
                                        onChange={e => setConfig({ managerPhone: e.target.value })}
                                        placeholder="Ex: 5511999999999"
                                        style={{
                                            width: '100%',
                                            padding: '12px 15px',
                                            background: '#F9F9FA',
                                            border: '1px solid #E5E5E7',
                                            borderRadius: '12px',
                                            fontSize: '14px',
                                            color: '#1d1d1f',
                                            outline: 'none'
                                        }}
                                    />
                                </div>
                            </div>

                            {safeKB.length === 0 && !hasRawBriefing ? (
                                <div style={{ textAlign: 'center', padding: '60px 20px' }}>
                                    <div style={{ background: '#F9F9FA', display: 'inline-flex', padding: '20px', borderRadius: '50%', marginBottom: '20px' }}>
                                        <Brain size={40} color="#E5E5E7" />
                                    </div>
                                    <h3 style={{ color: '#1d1d1f', marginBottom: '10px' }}>C√©rebro N√£o Estruturado</h3>
                                    <p style={{ color: '#86868b', maxWidth: '400px', margin: '0 auto 30px auto', lineHeight: '1.5' }}>
                                        A Aura ainda n√£o possui um mapa mental estruturado do seu neg√≥cio.
                                        Inicie a entrevista para criar regras claras de atendimento.
                                    </p>
                                    <button onClick={() => setView('interview')} className="btn-primary" style={{ padding: '15px 40px', borderRadius: '50px', fontWeight: 'bold' }}>
                                        Iniciar Entrevista Guiada <ArrowRight size={16} />
                                    </button>
                                </div>
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '25px' }}>
                                    {safeKB.map((point) => (
                                        <div key={point.id} className="knowledge-card" style={{
                                            padding: '30px',
                                            background: '#FFFFFF',
                                            border: '1px solid #E5E5E7',
                                            borderRadius: '24px',
                                            boxShadow: '0 4px 12px rgba(0,0,0,0.03)'
                                        }}>
                                            {/* QUESTION - BOLD AS REQUESTED */}
                                            <div style={{ color: '#1d1d1f', fontSize: '16px', fontWeight: '800', marginBottom: '12px', lineHeight: '1.4' }}>
                                                {point.q}
                                            </div>

                                            {/* ANSWER */}
                                            <div style={{ position: 'relative', marginBottom: '20px' }}>
                                                {editingId === point.id ? (
                                                    <textarea
                                                        autoFocus
                                                        value={tempAnswer}
                                                        onChange={e => setTempAnswer(e.target.value)}
                                                        style={{ width: '100%', background: '#F9F9FA', border: '1px solid var(--accent-primary)', borderRadius: '12px', padding: '15px', color: '#1d1d1f', outline: 'none' }}
                                                    />
                                                ) : (
                                                    <div style={{ color: '#4a4a4c', fontSize: '14px', lineHeight: '1.6' }}>{point.a}</div>
                                                )}

                                                <div style={{ position: 'absolute', top: 0, right: 0 }}>
                                                    {editingId === point.id ? (
                                                        <div style={{ display: 'flex', gap: '10px' }}>
                                                            <button onClick={() => handleUpdatePoint(point.id)} style={{ color: '#C5A059', border: 'none', background: 'none', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px' }}>SALVAR</button>
                                                            <button onClick={() => setEditingId(null)} style={{ color: '#86868b', border: 'none', background: 'none', cursor: 'pointer', fontSize: '11px' }}>CANCELAR</button>
                                                        </div>
                                                    ) : (
                                                        <Edit2 size={14} color="#86868b" style={{ cursor: 'pointer' }} onClick={() => { setEditingId(point.id); setTempAnswer(point.a); }} />
                                                    )}
                                                </div>
                                            </div>

                                            {/* AI ANALYSIS - INTEGRATED AFTER RESPONSE AS REQUESTED */}
                                            {point.analysis && (
                                                <div style={{
                                                    marginTop: '15px',
                                                    padding: '18px',
                                                    background: '#F9F9FA', /* CHANGED: Clean Gray */
                                                    border: '1px solid #E5E5E7', /* CHANGED: Clean Border */
                                                    borderRadius: '16px',
                                                    display: 'flex',
                                                    gap: '12px'
                                                }}>
                                                    <Sparkles size={16} color="var(--accent-primary)" style={{ flexShrink: 0, marginTop: '2px' }} />
                                                    <div>
                                                        <span style={{ display: 'block', fontSize: '11px', fontWeight: '800', color: 'var(--accent-primary)', textTransform: 'uppercase', marginBottom: '5px' }}>Insight Estrat√©gico Aura</span>
                                                        <p style={{ margin: 0, fontSize: '13px', color: '#6d6d6f', lineHeight: '1.5', fontStyle: 'italic' }}>
                                                            {point.analysis}
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    ))}

                                    {/* Action to add more or restart */}
                                    <div style={{
                                        marginTop: '30px',
                                        padding: '20px',
                                        borderRadius: '20px',
                                        background: '#F9F9FA',
                                        border: '1px solid #E5E5E7',
                                        display: 'flex',
                                        flexDirection: 'column',
                                        alignItems: 'center',
                                        gap: '15px'
                                    }}>
                                        <p style={{ margin: 0, fontSize: '13px', color: '#86868b' }}>Deseja expandir o conhecimento da Aura?</p>
                                        <button onClick={() => setView('interview')} className="btn-secondary" style={{ borderRadius: '50px', padding: '10px 30px', fontSize: '12px' }}>
                                            <Plus size={14} style={{ marginRight: '5px' }} /> Continuar Entrevista
                                        </button>
                                    </div>

                                    <div style={{ textAlign: 'center', marginTop: '10px' }}>
                                        <button onClick={onClose} className="btn-primary" style={{ padding: '15px 60px', borderRadius: '50px' }}>
                                            Finalizar e Salvar
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default BriefingModal;


--- FILE: src/components/CRMCard.jsx ---

import React, { useState } from 'react';
import { MessageCircle, Brain } from 'lucide-react';
import { useStore } from '../store/useStore';
import { formatJid } from '../utils/formatter';
import OpenAIService from '../services/openai';

const CRMCard = ({ chat, tag }) => {
    const { setActiveChat, chatNextSteps, setNextSteps, messages } = useStore();
    const [analyzing, setAnalyzing] = useState(false);

    const jid = chat.remoteJid || chat.jid || chat.id;
    const msg = chat.lastMessage?.message || chat.message || {};

    let name = [
        chat.name,
        chat.pushName,
        chat.verifiedName,
        chat.lastMessage?.pushName,
    ].find(n => n && n !== 'Voc√™' && !n.includes('@lid'));

    const patientName = name || formatJid(jid);

    // Get last message preview
    const lastMessage = (() => {
        const content = msg.conversation ||
            msg.extendedTextMessage?.text ||
            msg.imageMessage?.caption || "";

        if (content) return content.length > 60 ? content.substring(0, 60) + "..." : content;
        if (msg.audioMessage) return "üéµ √Åudio";
        if (msg.imageMessage) return "üì∏ Imagem";
        return "Sem mensagens recentes";
    })();

    // Time ago calculation
    const getTimeAgo = () => {
        const ts = chat.lastMessage?.messageTimestamp || chat.messageTimestamp || 0;
        const now = Date.now();
        const diff = now - (ts * 1000);

        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (minutes < 60) return `${minutes}m atr√°s`;
        if (hours < 24) return `${hours}h atr√°s`;
        return `${days}d atr√°s`;
    };

    const nextSteps = chatNextSteps[jid];

    const handleAnalyze = async (e) => {
        e.stopPropagation();
        setAnalyzing(true);

        try {
            // Format chat history for AI
            const chatHistory = messages
                .map(m => {
                    const isFromMe = m.key?.fromMe;
                    const text = m.message?.conversation ||
                        m.message?.extendedTextMessage?.text ||
                        '[M√≠dia]';
                    return `${isFromMe ? 'Cl√≠nica' : patientName}: ${text}`;
                })
                .join('\n');

            const result = await OpenAIService.analyzeNextSteps(
                chatHistory || 'Conversa ainda n√£o carregada',
                patientName,
                tag.name
            );

            setNextSteps(jid, result);
        } catch (error) {
            console.error('Error analyzing next steps:', error);
        } finally {
            setAnalyzing(false);
        }
    };

    const handleOpenChat = () => {
        setActiveChat({ id: jid, name: patientName });
        useStore.getState().setCurrentView('dashboard');
    };

    const getPriorityColor = (priority) => {
        switch (priority) {
            case 'high': return '#ef4444';
            case 'medium': return '#f59e0b';
            case 'low': return '#10b981';
            default: return '#6b7280';
        }
    };

    const getPriorityLabel = (priority) => {
        switch (priority) {
            case 'high': return 'üî¥ Alta';
            case 'medium': return 'üü° M√©dia';
            case 'low': return 'üü¢ Baixa';
            default: return 'Normal';
        }
    };

    return (
        <div className="crm-card" onClick={handleOpenChat}>
            <div className="card-header" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                <h4 style={{ margin: 0, fontSize: '14px', fontWeight: '600', color: 'var(--text-main)' }}>
                    {patientName}
                </h4>
                <span style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
                    {getTimeAgo()}
                </span>
            </div>

            <p style={{ fontSize: '12px', color: 'var(--text-muted)', margin: '0 0 10px 0', lineHeight: '1.4' }}>
                {lastMessage}
            </p>

            {nextSteps && (
                <div className="next-steps" style={{
                    background: '#f8fafc',
                    borderRadius: '8px',
                    padding: '12px',
                    marginBottom: '10px',
                    fontSize: '12px',
                    border: '1px solid #e2e8f0'
                }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <span style={{ fontWeight: '800', color: '#1d1d1f', textTransform: 'uppercase', fontSize: '10px', letterSpacing: '0.5px' }}>
                            AN√ÅLISE AURA
                        </span>
                        {/* TEMPERATURE BADGE */}
                        {nextSteps.temperature && (
                            <span style={{
                                fontSize: '10px',
                                fontWeight: 'bold',
                                padding: '2px 8px',
                                borderRadius: '10px',
                                background: nextSteps.temperature === 'quente' ? '#fee2e2' : (nextSteps.temperature === 'frio' ? '#e2e8f0' : '#fef3c7'),
                                color: nextSteps.temperature === 'quente' ? '#ef4444' : (nextSteps.temperature === 'frio' ? '#64748b' : '#d97706')
                            }}>
                                {nextSteps.temperature === 'quente' ? 'üî• QUENTE' : (nextSteps.temperature === 'frio' ? '‚ùÑÔ∏è FRIO' : 'üå°Ô∏è MORNO')}
                            </span>
                        )}
                    </div>

                    {/* SUMMARY */}
                    {nextSteps.summary && (
                        <div style={{ marginBottom: '8px', fontStyle: 'italic', color: '#475569', lineHeight: '1.4' }}>
                            "{nextSteps.summary}"
                        </div>
                    )}

                    <h5 style={{ margin: '8px 0 4px 0', fontSize: '10px', fontWeight: 'bold', color: '#64748b' }}>
                        SUGEST√ÉO:
                    </h5>
                    <ul style={{ margin: '0', paddingLeft: '15px', color: '#334155' }}>
                        {nextSteps.steps?.map((step, i) => (
                            <li key={i} style={{ marginBottom: '3px', lineHeight: '1.4' }}>{step}</li>
                        ))}
                    </ul>
                </div>
            )}

            <div className="card-actions" style={{ display: 'flex', gap: '8px', marginTop: '10px' }}>
                <button
                    onClick={handleOpenChat}
                    style={{
                        flex: 1,
                        padding: '8px',
                        background: 'var(--accent-primary)',
                        color: '#000',
                        border: 'none',
                        borderRadius: '6px',
                        fontSize: '12px',
                        fontWeight: '600',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '4px'
                    }}
                >
                    <MessageCircle size={14} />
                    Abrir
                </button>
                <button
                    onClick={handleAnalyze}
                    disabled={analyzing}
                    style={{
                        flex: 1,
                        padding: '8px',
                        background: analyzing ? '#e5e7eb' : '#3b82f6',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '6px',
                        fontSize: '12px',
                        fontWeight: '600',
                        cursor: analyzing ? 'not-allowed' : 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '4px',
                        opacity: analyzing ? 0.6 : 1
                    }}
                >
                    <Brain size={14} />
                    {analyzing ? 'Analisando...' : 'Analisar'}
                </button>
            </div>
        </div>
    );
};

export default CRMCard;


--- FILE: src/components/CRMColumn.jsx ---

import React from 'react';
import CRMCard from './CRMCard';

const CRMColumn = ({ tag, chats }) => {
    return (
        <div className="crm-column" style={{
            background: 'white',
            borderRadius: '20px',
            padding: '20px',
            minWidth: '300px',
            border: '1px solid rgba(0,0,0,0.05)',
            boxShadow: '0 4px 12px rgba(0,0,0,0.02)',
            display: 'flex',
            flexDirection: 'column',
            gap: '15px'
        }}>
            <div className="column-header" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '5px' }}>
                <span style={{ fontSize: '14px', fontWeight: '800', color: '#1d1d1f', display: 'flex', alignItems: 'center', gap: '8px', flex: 1 }}>
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: tag.color }}></div>
                    <input
                        type="text"
                        defaultValue={tag.name}
                        onBlur={(e) => {
                            if (e.target.value !== tag.name) {
                                // Assuming we'll pass an update function or use store directly
                                const { useStore } = require('../store/useStore');
                                useStore.getState().updateCRMColumn(tag.id, { name: e.target.value });
                            }
                        }}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter') e.target.blur();
                        }}
                        style={{
                            border: 'none',
                            background: 'transparent',
                            fontSize: '14px',
                            fontWeight: '800',
                            color: '#1d1d1f',
                            outline: 'none',
                            width: '100%',
                            cursor: 'text'
                        }}
                    />
                </span>
                <span className="count" style={{
                    background: 'rgba(0,0,0,0.03)',
                    color: '#86868b',
                    padding: '4px 12px',
                    borderRadius: '100px',
                    fontSize: '11px',
                    fontWeight: 'bold'
                }}>
                    {chats.length}
                </span>
            </div>

            <div className="column-body scrollable">
                {chats.length === 0 ? (
                    <div style={{
                        padding: '40px 20px',
                        textAlign: 'center',
                        color: 'var(--text-muted)',
                        fontSize: '13px'
                    }}>
                        Nenhum lead neste est√°gio
                    </div>
                ) : (
                    chats.map(chat => {
                        const jid = chat.remoteJid || chat.jid || chat.id;
                        return (
                            <CRMCard
                                key={jid}
                                chat={chat}
                                tag={tag}
                            />
                        );
                    })
                )}
            </div>
        </div>
    );
};

export default CRMColumn;


--- FILE: src/components/CRMView.jsx ---

import React from 'react';
import { useStore } from '../store/useStore';
import CRMColumn from './CRMColumn';

const CRMView = () => {
    const { tags, chats, chatTags } = useStore();

    // Calculate stats
    const totalLeads = Object.keys(chatTags).length;
    const fechadosCount = Object.values(chatTags).filter(t => t === 'fechado').length;
    const conversionRate = totalLeads > 0 ? Math.round((fechadosCount / totalLeads) * 100) : 0;

    return (
        <div className="crm-container" style={{ background: '#FDFDFD', height: '100%', padding: '30px', display: 'flex', flexDirection: 'column' }}>
            <div className="crm-header" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '35px' }}>
                <div>
                    <h2 style={{ margin: 0, color: '#1d1d1f', fontSize: '24px', fontWeight: 'bold' }}>Pipeline de Vendas</h2>
                    <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#86868b' }}>
                        Acompanhe o funil de convers√£o e gerencie seus leads
                    </p>
                </div>
                <div className="crm-stats" style={{ display: 'flex', gap: '20px' }}>
                    <div className="stat-card" style={{ background: 'white', padding: '15px 25px', borderRadius: '16px', border: '1px solid rgba(0,0,0,0.05)', boxShadow: '0 4px 10px rgba(0,0,0,0.03)', textAlign: 'right' }}>
                        <div style={{ fontSize: '11px', color: '#86868b', textTransform: 'uppercase', fontWeight: 'bold', marginBottom: '5px' }}>Total de Leads</div>
                        <div style={{ fontSize: '20px', fontWeight: 'bold', color: '#1d1d1f' }}>{totalLeads}</div>
                    </div>
                    <div className="stat-card" style={{ background: 'white', padding: '15px 25px', borderRadius: '16px', border: '1px solid rgba(0,0,0,0.05)', boxShadow: '0 4px 10px rgba(0,0,0,0.03)', textAlign: 'right' }}>
                        <div style={{ fontSize: '11px', color: '#86868b', textTransform: 'uppercase', fontWeight: 'bold', marginBottom: '5px' }}>Convers√£o</div>
                        <div style={{ fontSize: '20px', fontWeight: 'bold', color: 'var(--accent-primary)' }}>{conversionRate}%</div>
                    </div>
                </div>
            </div>

            <div className="crm-board" style={{ overflowX: 'auto', paddingBottom: '20px' }}>
                <div style={{ display: 'flex', gap: '20px', minWidth: 'min-content' }}>
                    {tags.map(tag => {
                        const tagChats = chats.filter(c => {
                            const jid = c.remoteJid || c.jid || c.id;
                            return chatTags[jid] === tag.id;
                        });

                        return (
                            <CRMColumn
                                key={tag.id}
                                tag={tag}
                                chats={tagChats}
                            />
                        );
                    })}

                    {/* ADD COLUMN BUTTON */}
                    <button
                        onClick={() => useStore.getState().addCRMColumn("Nova Etapa")}
                        style={{
                            minWidth: '300px',
                            height: '60px',
                            borderRadius: '20px',
                            border: '2px dashed #E5E5E7',
                            background: 'transparent',
                            color: '#86868b',
                            fontSize: '14px',
                            fontWeight: 'bold',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '10px',
                            transition: 'all 0.2s'
                        }}
                        onMouseOver={e => { e.currentTarget.style.borderColor = 'var(--accent-primary)'; e.currentTarget.style.color = 'var(--accent-primary)'; }}
                        onMouseOut={e => { e.currentTarget.style.borderColor = '#E5E5E7'; e.currentTarget.style.color = '#86868b'; }}
                    >
                        + Adicionar Etapa
                    </button>
                </div>
            </div>
        </div>
    );
};

export default CRMView;


--- FILE: src/components/ChatArea.jsx ---

import React, { useState } from 'react';
import { Zap, X } from 'lucide-react';
import { useStore } from '../store/useStore';
import { useChatDialogs } from '../hooks/useChatDialogs';
import { useChatComposer } from '../hooks/useChatComposer';
import { useChatAI } from '../hooks/useChatAI';
import { useChatThread } from '../hooks/useChatThread';
import { useChatActions } from '../hooks/useChatActions.jsx';
import ChatDialogModal from './ChatDialogModal';
import ChatMobileAnalysisOverlay from './ChatMobileAnalysisOverlay';
import MessageList from './MessageList';
import ChatInsightsPanel from './ChatInsightsPanel';
import ChatHeader from './ChatHeader';
import ChatComposer from './ChatComposer';
import ChatEmptyState from './ChatEmptyState';

const ChatArea = ({ isArchived = false, onBack }) => {
    const { activeChat, messages, setMessages, clearMessages, briefing, setActiveChat, chatTags, tags } = useStore();

    const [input, setInput] = useState('');
    const [sending, setSending] = useState(false);
    const [showAttachMenu, setShowAttachMenu] = useState(false);
    const [isAnalysisOpen, setIsAnalysisOpen] = useState(false); // Mobile Analysis Overlay state
    const { suggestion, analysisData, isEnhancing, handleAnalyze, handleEnhance } = useChatAI({
        activeChat,
        messages,
        briefing,
        setInput,
    });

    const {
        dialog,
        dialogInput,
        setDialogInput,
        openConfirm,
        openPrompt,
        handleDialogClose,
        handleDialogConfirm,
    } = useChatDialogs();

    const { loading, messagesEndRef, loadMessages } = useChatThread({
        activeChat,
        messages,
        setMessages,
        clearMessages,
    });

    const {
        recording,
        handleMicClick,
        handleSend,
        useSuggestion,
        handleFileSelect,
        handleAttachmentMenuOpen,
    } = useChatComposer({
        activeChat,
        input,
        setInput,
        suggestion,
        sending,
        setSending,
        loadMessages,
        setShowAttachMenu,
        openConfirm,
        openPrompt,
    });

    const { handleTag, handleUnarchive, handleArchive } = useChatActions({
        activeChat,
        openConfirm,
        setActiveChat,
    });

    if (!activeChat) {
        return <ChatEmptyState />;
    }

    return (
        <main className="chat-area" style={{ position: 'relative' }}>
            <ChatDialogModal
                dialog={dialog}
                dialogInput={dialogInput}
                setDialogInput={setDialogInput}
                handleDialogClose={handleDialogClose}
                handleDialogConfirm={handleDialogConfirm}
            />

            <ChatMobileAnalysisOverlay
                isOpen={isAnalysisOpen}
                onClose={() => setIsAnalysisOpen(false)}
                analysisData={analysisData}
                handleAnalyze={handleAnalyze}
            />

            <ChatHeader
                activeChat={activeChat}
                chatTags={chatTags}
                tags={tags}
                isArchived={isArchived}
                onBack={onBack}
                onOpenAnalysis={() => setIsAnalysisOpen(true)}
                onTag={handleTag}
                onArchive={handleArchive}
                onUnarchive={handleUnarchive}
            />

            <div className="main-grid">
                <div className="messages-column glass-panel">
                    <MessageList messages={messages} loading={loading} messagesEndRef={messagesEndRef} />

                    <ChatComposer
                        showAttachMenu={showAttachMenu}
                        setShowAttachMenu={setShowAttachMenu}
                        handleAttachmentMenuOpen={handleAttachmentMenuOpen}
                        handleFileSelect={handleFileSelect}
                        handleSend={handleSend}
                        input={input}
                        setInput={setInput}
                        handleEnhance={handleEnhance}
                        isEnhancing={isEnhancing}
                        sending={sending}
                        recording={recording}
                        handleMicClick={handleMicClick}
                    />
                </div>

                <ChatInsightsPanel
                    analysisData={analysisData}
                    suggestion={suggestion}
                    handleAnalyze={handleAnalyze}
                    useSuggestion={useSuggestion}
                />
            </div>
        </main >
    );
};

export default ChatArea;


--- FILE: src/components/ChatComposer.jsx ---

import React, { useRef } from 'react';
import { Paperclip, Wand2, Send, Mic, Image, Camera, FileText } from 'lucide-react';

const ChatComposer = ({
    showAttachMenu,
    setShowAttachMenu,
    handleFileSelect,
    handleAttachmentMenuOpen,
    handleSend,
    input,
    setInput,
    handleEnhance,
    isEnhancing,
    sending,
    recording,
    handleMicClick,
}) => {
    const fileInputRef = useRef(null);

    const handleOptionClick = (type) => {
        if (!fileInputRef.current) return;

        // Configure input based on type
        if (type === 'Fotos/V√≠deos') {
            fileInputRef.current.accept = 'image/*,video/*';
            fileInputRef.current.removeAttribute('capture');
        } else if (type === 'Documento') {
            fileInputRef.current.accept = '.pdf,.doc,.docx,.txt,.xlsx,.xls';
            fileInputRef.current.removeAttribute('capture');
        } else if (type === 'C√¢mera') {
            fileInputRef.current.accept = 'image/*';
            fileInputRef.current.capture = 'environment';
        }

        setShowAttachMenu(false);
        // Small timeout to ensure menu closes visually before system dialog opens (optional but smoother)
        setTimeout(() => {
            fileInputRef.current.click();
        }, 50);
    };

    return (
        <form className="message-input-area" onSubmit={handleSend} style={{ position: 'relative' }}>
            {/* Hidden Permanent File Input */}
            <input
                type="file"
                ref={fileInputRef}
                style={{ display: 'none' }}
                onChange={handleFileSelect}
            />

            {showAttachMenu && (
                <div
                    className="attach-menu glass-panel"
                    style={{
                        position: 'absolute',
                        bottom: '75px',
                        left: '12px',
                        background: 'rgba(18, 18, 18, 0.98)',
                        backdropFilter: 'blur(30px)',
                        WebkitBackdropFilter: 'blur(30px)',
                        border: '1px solid rgba(197, 160, 89, 0.15)',
                        borderRadius: '24px',
                        padding: '10px',
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '6px',
                        zIndex: 1000,
                        minWidth: '220px',
                        boxShadow: '0 20px 50px rgba(0, 0, 0, 0.5)',
                        animation: 'fadeInUp 0.3s cubic-bezier(0.16, 1, 0.3, 1)',
                        transformOrigin: 'bottom left'
                    }}
                >
                    <button
                        type="button"
                        className="menu-item-v5"
                        onClick={() => handleOptionClick('Fotos/V√≠deos')}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'flex-start',
                            gap: '14px',
                            background: 'transparent',
                            border: 'none',
                            color: '#ffffff',
                            cursor: 'pointer',
                            padding: '14px 18px',
                            fontSize: '15px',
                            fontWeight: '600',
                            textAlign: 'left',
                            width: '100%',
                            borderRadius: '16px',
                            transition: 'all 0.2s',
                        }}
                        onMouseEnter={(e) => { e.currentTarget.style.background = 'rgba(197, 160, 89, 0.15)'; e.currentTarget.style.color = 'var(--accent-primary)'; }}
                        onMouseLeave={(e) => { e.currentTarget.style.background = 'transparent'; e.currentTarget.style.color = '#ffffff'; }}
                    >
                        <Image size={22} style={{ color: 'var(--accent-primary)' }} />
                        <span>Fotos e V√≠deos</span>
                    </button>

                    <button
                        type="button"
                        className="menu-item-v5"
                        onClick={() => handleOptionClick('C√¢mera')}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'flex-start',
                            gap: '14px',
                            background: 'transparent',
                            border: 'none',
                            color: '#ffffff',
                            cursor: 'pointer',
                            padding: '14px 18px',
                            fontSize: '15px',
                            fontWeight: '600',
                            textAlign: 'left',
                            width: '100%',
                            borderRadius: '16px',
                            transition: 'all 0.2s',
                        }}
                        onMouseEnter={(e) => { e.currentTarget.style.background = 'rgba(197, 160, 89, 0.15)'; e.currentTarget.style.color = 'var(--accent-primary)'; }}
                        onMouseLeave={(e) => { e.currentTarget.style.background = 'transparent'; e.currentTarget.style.color = '#ffffff'; }}
                    >
                        <Camera size={22} style={{ color: 'var(--accent-primary)' }} />
                        <span>Usar C√¢mera</span>
                    </button>

                    <button
                        type="button"
                        className="menu-item-v5"
                        onClick={() => handleOptionClick('Documento')}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'flex-start',
                            gap: '14px',
                            background: 'transparent',
                            border: 'none',
                            color: '#ffffff',
                            cursor: 'pointer',
                            padding: '14px 18px',
                            fontSize: '15px',
                            fontWeight: '600',
                            textAlign: 'left',
                            width: '100%',
                            borderRadius: '16px',
                            transition: 'all 0.2s',
                        }}
                        onMouseEnter={(e) => { e.currentTarget.style.background = 'rgba(197, 160, 89, 0.15)'; e.currentTarget.style.color = 'var(--accent-primary)'; }}
                        onMouseLeave={(e) => { e.currentTarget.style.background = 'transparent'; e.currentTarget.style.color = '#ffffff'; }}
                    >
                        <FileText size={22} style={{ color: 'var(--accent-primary)' }} />
                        <span>Documento</span>
                    </button>
                </div>
            )}

            <button
                type="button"
                className="btn-icon"
                onClick={handleAttachmentMenuOpen}
                style={{ background: 'none', border: 'none', color: 'var(--text-muted)', cursor: 'pointer', padding: '0 5px' }}
            >
                <Paperclip size={22} />
            </button>

            <div className="input-container-main">
                <button
                    type="button"
                    className={`btn-enhance ${input.trim() ? 'active' : ''}`}
                    onClick={() => handleEnhance(input)}
                    disabled={!input.trim() || isEnhancing || sending}
                    title="Aprimorar Resposta"
                >
                    <Wand2 size={18} className={isEnhancing ? 'spin' : ''} />
                </button>

                <input
                    type="text"
                    placeholder="Resposta persuasiva..."
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    disabled={sending || isEnhancing}
                />
            </div>

            {input.trim() ? (
                <button
                    type="submit"
                    disabled={sending || isEnhancing}
                    style={{
                        background: 'var(--accent-primary)',
                        color: '#000',
                        border: 'none',
                        borderRadius: '50%',
                        width: '48px',
                        height: '48px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        boxShadow: '0 2px 5px rgba(0,0,0,0.1)',
                        flexShrink: 0,
                    }}
                >
                    <Send size={20} />
                </button>
            ) : (
                <button
                    type="button"
                    onClick={handleMicClick}
                    style={{
                        background: recording ? '#ef4444' : 'var(--accent-primary)',
                        border: 'none',
                        color: recording ? '#fff' : '#000',
                        cursor: 'pointer',
                        borderRadius: '50%',
                        width: '48px',
                        height: '48px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        boxShadow: '0 2px 5px rgba(0,0,0,0.1)',
                        transition: 'all 0.2s',
                        flexShrink: 0,
                    }}
                >
                    <Mic size={20} className={recording ? 'pulse' : ''} />
                </button>
            )}
        </form>
    );
};

export default ChatComposer;


--- FILE: src/components/ChatDialogModal.jsx ---

const ChatDialogModal = ({
    dialog,
    dialogInput,
    setDialogInput,
    handleDialogClose,
    handleDialogConfirm,
}) => {
    if (!dialog?.isOpen) return null;

    return (
        <div
            style={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'rgba(0,0,0,0.7)',
                zIndex: 1000,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
            }}
        >
            <div
                className="glass-panel"
                style={{
                    padding: '20px',
                    width: '300px',
                    borderRadius: '12px',
                    border: '1px solid var(--glass-border)',
                    background: '#0f172a',
                }}
            >
                <h4 style={{ margin: '0 0 10px 0', color: '#fff' }}>{dialog.title}</h4>
                {dialog.message && <p style={{ color: '#ccc', marginBottom: '15px' }}>{dialog.message}</p>}

                {dialog.type === 'prompt' && (
                    <input
                        type="text"
                        value={dialogInput}
                        onChange={(e) => setDialogInput(e.target.value)}
                        placeholder={dialog.inputPlaceholder}
                        style={{
                            width: '100%',
                            padding: '8px',
                            borderRadius: '6px',
                            border: '1px solid #334155',
                            background: '#1e293b',
                            color: '#fff',
                            marginBottom: '15px',
                        }}
                        autoFocus
                    />
                )}

                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '10px' }}>
                    <button
                        onClick={handleDialogClose}
                        style={{
                            padding: '8px 16px',
                            background: 'transparent',
                            border: '1px solid #475569',
                            color: '#cbd5e1',
                            borderRadius: '6px',
                            cursor: 'pointer',
                        }}
                    >
                        Cancelar
                    </button>
                    <button
                        onClick={handleDialogConfirm}
                        style={{
                            padding: '8px 16px',
                            background: 'var(--accent-primary)',
                            border: 'none',
                            color: '#000',
                            fontWeight: 'bold',
                            borderRadius: '6px',
                            cursor: 'pointer',
                        }}
                    >
                        Confirmar
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ChatDialogModal;


--- FILE: src/components/ChatEmptyState.jsx ---

import logoDark from '../assets/logo-dark.png';

const ChatEmptyState = () => {
    return (
        <div className="empty-dashboard" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', gap: '20px' }}>
            <img src={logoDark} alt="AURA" style={{ width: '150px', opacity: 0.3 }} />
            <p style={{ opacity: 0.5 }}>Selecione um cliente para iniciar a consultoria de vendas</p>
        </div>
    );
};

export default ChatEmptyState;


--- FILE: src/components/ChatHeader.jsx ---

import React from 'react';
import { ChevronLeft, Pencil, Wand2, Archive, Tag } from 'lucide-react';
import { formatJid } from '../utils/formatter';

const ChatHeader = ({
    activeChat,
    chatTags,
    tags,
    isArchived,
    onBack,
    onOpenAnalysis,
    onTag,
    onArchive,
    onUnarchive,
}) => {
    return (
        <header className="chat-header glass-panel">
            <div className="active-info" style={{ flex: 1 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                    <button
                        className="mobile-back-btn"
                        onClick={onBack}
                        style={{ background: 'none', border: 'none', padding: 0, cursor: 'pointer', display: 'none', marginRight: '5px' }}
                    >
                        <ChevronLeft size={24} color="var(--accent-primary)" />
                    </button>
                    <h3 style={{ margin: 0 }}>
                        {activeChat.name && activeChat.name !== formatJid(activeChat.id) ? activeChat.name : formatJid(activeChat.id)}
                    </h3>
                    {chatTags[activeChat.id] && (() => {
                        const tag = tags.find((item) => item.id === chatTags[activeChat.id]);
                        if (!tag) return null;
                        return (
                            <span
                                style={{
                                    fontSize: '11px',
                                    background: `${tag.color}33`,
                                    color: tag.color,
                                    padding: '2px 8px',
                                    borderRadius: '12px',
                                    border: `1px solid ${tag.color}`,
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '4px',
                                    fontWeight: '600',
                                }}
                            >
                                {tag.icon} {tag.name}
                            </span>
                        );
                    })()}


                </div>
            </div>
            <div className="header-actions" style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                <button
                    className="mobile-analysis-btn"
                    onClick={onOpenAnalysis}
                    style={{ background: 'none', border: 'none', color: 'var(--accent-primary)', display: 'none', cursor: 'pointer', padding: '5px' }}
                >
                    <Wand2 size={22} />
                </button>
                {isArchived ? (
                    <button
                        className="icon-btn"
                        title="Desarquivar"
                        onClick={onUnarchive}
                        style={{ background: 'none', border: 'none', color: 'var(--success)', cursor: 'pointer' }}
                    >
                        <Archive size={20} />
                    </button>
                ) : (
                    <>
                        <button
                            className="icon-btn"
                            title="Etiquetar"
                            onClick={onTag}
                            style={{ background: 'none', border: 'none', color: 'var(--text-muted)', cursor: 'pointer' }}
                        >
                            <Tag size={20} />
                        </button>
                        <button
                            className="icon-btn"
                            title="Arquivar"
                            onClick={onArchive}
                            style={{ background: 'none', border: 'none', color: 'var(--text-muted)', cursor: 'pointer' }}
                        >
                            <Archive size={20} />
                        </button>
                    </>
                )}
            </div>
        </header>
    );
};

export default ChatHeader;


--- FILE: src/components/ChatInsightsPanel.jsx ---

import React from 'react';
import { BarChart3, Target, Check } from 'lucide-react';

const ChatInsightsPanel = ({ analysisData, suggestion, handleAnalyze, useSuggestion }) => {
    return (
        <div className="analysis-column">
            <div className="card glass-panel v3-analysis">
                <div className="card-header-v3">
                    <BarChart3 size={18} />
                    <h4>An√°lise de Vendas</h4>
                </div>

                <div className="v3-data-grid">
                    <div className="data-item">
                        <label>Consci√™ncia</label>
                        <span>{analysisData.level || '‚Äî'}</span>
                    </div>
                    <div className="data-item">
                        <label>Inten√ß√£o Principal</label>
                        <span>{analysisData.intent || '‚Äî'}</span>
                    </div>
                    <div className="data-item">
                        <label>Estrat√©gia</label>
                        <span>{analysisData.strategy || '‚Äî'}</span>
                    </div>
                </div>

                <button className="btn-primary v3-btn" onClick={handleAnalyze}>
                    Analisar Hist√≥rico
                </button>
            </div>

            <div className="card glass-panel suggestion v3-suggestion">
                <div className="card-header-v3">
                    <Target size={18} />
                    <h4>Resposta Sugerida</h4>
                </div>
                <div className="result-box v3-box">
                    {suggestion || 'Aguardando an√°lise estrat√©gica...'}
                </div>
                {suggestion && !suggestion.includes('...') && (
                    <button className="btn-secondary v3-btn-sub" onClick={useSuggestion}>
                        <Check size={16} /> Usar esta sugest√£o
                    </button>
                )}
            </div>
        </div>
    );
};

export default ChatInsightsPanel;


--- FILE: src/components/ChatList.jsx ---

import React, { useState } from 'react';
import { Search, RefreshCw, Menu } from 'lucide-react';
import { useStore } from '../store/useStore';
import WhatsAppService from '../services/whatsapp';
import { useArchivedChats } from '../hooks/useArchivedChats';
import { getChatDisplayName, getChatJid, getChatTimestampMs } from '../utils/chatList';
import ChatListItem from './ChatListItem';

const ChatList = ({ onOpenMenu }) => {
    const { chats, setChats, activeChat, setActiveChat, isConnected } = useStore();
    const [loading, setLoading] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const archivedChatIds = useArchivedChats();

    const loadData = async () => {
        if (loading) return;
        setLoading(true);
        try {
            const data = await WhatsAppService.fetchChats();
            if (data) setChats(data);
        } catch (e) {
            console.error("AURA ChatList Error:", e);
        }
        setLoading(false);
    };

    const filtered = (Array.isArray(chats) ? chats : [])
        .filter(c => {
            const jid = getChatJid(c);
            // Exclude archived chats from main list
            if (archivedChatIds.includes(jid)) return false;

            const jidStr = String(jid || "").toLowerCase();
            const name = String(getChatDisplayName(c) || "").toLowerCase();
            const term = String(searchTerm || "").toLowerCase().trim();
            return name.includes(term) || jidStr.includes(term);
        })
        .sort((a, b) => getChatTimestampMs(b) - getChatTimestampMs(a));

    return (
        <div className="chat-list-container glass-panel">
            <div className="list-header">
                <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                    <button className="mobile-menu-btn" onClick={onOpenMenu} style={{ background: 'none', border: 'none', padding: 0, cursor: 'pointer', display: 'none' }}>
                        <Menu size={24} color="#1d1d1f" />
                    </button>
                    <h2>Mensagens</h2>
                </div>
                <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                    {!isConnected && <span style={{ fontSize: '10px', color: '#ff4444' }}>Offline</span>}
                    <RefreshCw
                        size={18}
                        className={loading ? 'spin' : 'btn-refresh'}
                        onClick={loadData}
                        style={{ cursor: 'pointer' }}
                    />
                </div>
            </div>

            <div className="search-bar">
                <Search size={16} />
                <input
                    type="text"
                    placeholder="Buscar..."
                    value={searchTerm}
                    onChange={e => setSearchTerm(e.target.value)}
                />
            </div>

            <div className="chats scrollable">
                {filtered.map(chat => {
                    return (
                        <ChatListItem
                            key={String(getChatJid(chat))}
                            chat={chat}
                            activeChatId={activeChat?.id}
                            onSelect={setActiveChat}
                            includeAudioTranscription
                        />
                    );
                })}

                {filtered.length === 0 && !loading && (
                    <div className="empty-state" style={{ padding: '20px', textAlign: 'center', opacity: 0.5 }}>
                        <p>{searchTerm ? 'Nenhum contato encontrado.' : 'Nenhuma conversa carregada.'}</p>
                        {searchTerm.length > 5 && !searchTerm.includes('@') && (
                            <button
                                className="btn-force"
                                style={{ marginTop: '10px' }}
                                onClick={() => setActiveChat({ id: `${searchTerm.replace(/\D/g, '')}@s.whatsapp.net`, name: 'Busca Direta' })}
                            >
                                Buscar n√∫mero: {searchTerm.replace(/\D/g, '')}
                            </button>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

export default ChatList;


--- FILE: src/components/ChatListItem.jsx ---

import React from 'react';
import { formatJid } from '../utils/formatter';
import { getChatAvatar, getChatDisplayName, getChatJid, getChatPreview } from '../utils/chatList';

const rowStyles = {
    display: 'flex',
    flexDirection: 'column',
    gap: '2px',
    alignItems: 'flex-start',
};

const titleStyles = {
    margin: 0,
    fontSize: '14px',
    fontWeight: 'bold',
    textAlign: 'left',
};

const jidStyles = {
    fontSize: '11px',
    opacity: 0.6,
    fontWeight: '400',
    textAlign: 'left',
};

const avatarStyles = {
    width: '100%',
    height: '100%',
    borderRadius: '50%',
    objectFit: 'cover',
};

const ChatListItem = ({ chat, activeChatId, onSelect, includeAudioTranscription = false }) => {
    const jid = getChatJid(chat);
    const name = getChatDisplayName(chat);
    const photo = getChatAvatar(chat);
    const hasName = name && name !== String(jid).split('@')[0];
    const preview = getChatPreview(chat, { includeAudioTranscription });

    return (
        <div
            key={String(jid)}
            className={`chat-item ${activeChatId === jid ? 'active' : ''}`}
            onClick={() =>
                onSelect({
                    ...chat,
                    id: jid,
                    name: name || formatJid(jid),
                    jid: chat?.jid || jid,
                    remoteJid: chat?.remoteJid || jid,
                    remoteJidAlt: chat?.remoteJidAlt || chat?.lastMessage?.key?.remoteJidAlt || null,
                    linkedLid: chat?.linkedLid || null,
                    phoneNumber: chat?.phoneNumber || null,
                    sendTargetJid: chat?.sendTargetJid || null,
                })
            }
        >
            <div className="avatar">
                {photo ? (
                    <img src={photo} alt={name || 'Avatar'} style={avatarStyles} />
                ) : (
                    (name || '#')[0]?.toUpperCase()
                )}
            </div>
            <div className="info">
                <div className="chat-main-header" style={rowStyles}>
                    <h4 style={titleStyles}>{hasName ? name : formatJid(jid)}</h4>
                    {hasName && !jid.includes('@lid') && (
                        <span style={jidStyles}>{formatJid(jid)}</span>
                    )}
                </div>
                <p className="chat-preview">{preview}</p>
            </div>
        </div>
    );
};

export default ChatListItem;


--- FILE: src/components/ChatMobileAnalysisOverlay.jsx ---

import React from 'react';
import { Bot, Wand2 } from 'lucide-react';

const ChatMobileAnalysisOverlay = ({ isOpen, onClose, analysisData, handleAnalyze }) => {
    if (!isOpen) return null;

    return (
        <div className="sidebar-overlay open" onClick={onClose} style={{ zIndex: 2000 }}>
            <div
                className="glass-panel"
                style={{
                    position: 'absolute',
                    bottom: 0,
                    left: 0,
                    width: '100%',
                    maxHeight: '80vh',
                    borderTopLeftRadius: '25px',
                    borderTopRightRadius: '25px',
                    padding: '30px 20px',
                    overflowY: 'auto',
                }}
                onClick={(e) => e.stopPropagation()}
            >
                <div
                    style={{ width: '40px', height: '5px', background: '#ccc', borderRadius: '5px', margin: '0 auto 20px auto' }}
                    onClick={onClose}
                />
                <h2 style={{ marginBottom: '20px', fontSize: '20px', textAlign: 'center' }}>An√°lise Estrat√©gica</h2>

                {analysisData.level ? (
                    <div className="analysis-content">
                        <div style={{ marginBottom: '15px', background: 'rgba(0,0,0,0.03)', padding: '15px', borderRadius: '12px' }}>
                            <h4 style={{ color: 'var(--accent-primary)', fontSize: '11px', textTransform: 'uppercase', marginBottom: '8px', letterSpacing: '0.5px' }}>N√≠vel de Consci√™ncia</h4>
                            <p style={{ fontSize: '15px', lineHeight: '1.4' }}>{analysisData.level}</p>
                        </div>
                        <div style={{ marginBottom: '15px', background: 'rgba(0,0,0,0.03)', padding: '15px', borderRadius: '12px' }}>
                            <h4 style={{ color: 'var(--accent-primary)', fontSize: '11px', textTransform: 'uppercase', marginBottom: '8px', letterSpacing: '0.5px' }}>Inten√ß√£o do Lead</h4>
                            <p style={{ fontSize: '15px', lineHeight: '1.4' }}>{analysisData.intent}</p>
                        </div>
                        <div style={{ background: 'rgba(0,0,0,0.03)', padding: '15px', borderRadius: '12px' }}>
                            <h4 style={{ color: 'var(--accent-primary)', fontSize: '11px', textTransform: 'uppercase', marginBottom: '8px', letterSpacing: '0.5px' }}>Estrat√©gia Recomendada</h4>
                            <p style={{ fontSize: '15px', lineHeight: '1.4' }}>{analysisData.strategy}</p>
                        </div>
                    </div>
                ) : (
                    <div style={{ textAlign: 'center', padding: '40px 0', opacity: 0.5 }}>
                        <Bot size={40} style={{ marginBottom: '10px' }} />
                        <p>Nenhuma an√°lise dispon√≠vel.<br />Clique em "Analisar Conversa" abaixo.</p>
                    </div>
                )}

                <button
                    className="btn-primary v3-btn"
                    onClick={() => {
                        handleAnalyze();
                        onClose();
                    }}
                    style={{ width: '100%', marginTop: '30px', height: '54px', borderRadius: '16px', fontWeight: 'bold' }}
                >
                    <Wand2 size={20} /> Analisar agora
                </button>
            </div>
        </div>
    );
};

export default ChatMobileAnalysisOverlay;


--- FILE: src/components/ConfigModal.jsx ---

import React from 'react';
import { useStore } from '../store/useStore';
import { X, Save, Phone } from 'lucide-react';

const ConfigModal = ({ isOpen, onClose }) => {
    const {
        apiUrl, apiKey, instanceName, managerPhone, setConfig
    } = useStore();

    const [localConfig, setLocalConfig] = React.useState({
        apiUrl: '',
        apiKey: '',
        instanceName: '',
        managerPhone: ''
    });

    React.useEffect(() => {
        if (isOpen) {
            setLocalConfig({ apiUrl, apiKey, instanceName, managerPhone });
        }
    }, [isOpen, apiUrl, apiKey, instanceName, managerPhone]);

    if (!isOpen) return null;

    const handleSave = () => {
        setConfig(localConfig);
        onClose();
    };

    return (
        <div className="modal-overlay" onClick={onClose} style={{ zIndex: 1000 }}>
            <div className="modal-content glass-panel" onClick={e => e.stopPropagation()} style={{ maxWidth: '450px', width: '100%' }}>
                <div className="modal-header">
                    <h2>Configura√ß√µes AURA</h2>
                    <button className="icon-btn" onClick={onClose}><X size={20} /></button>
                </div>

                <div className="modal-body" style={{ display: 'flex', flexDirection: 'column', gap: '20px', padding: '10px 0' }}>
                    <div className="input-group">
                        <label>Endpoint API (Evolution)</label>
                        <input
                            type="text"
                            value={localConfig.apiUrl}
                            onChange={e => setLocalConfig({ ...localConfig, apiUrl: e.target.value })}
                            placeholder="https://sua-api.com"
                        />
                    </div>

                    <div className="input-group">
                        <label>API Key</label>
                        <input
                            type="password"
                            value={localConfig.apiKey}
                            onChange={e => setLocalConfig({ ...localConfig, apiKey: e.target.value })}
                            placeholder="Chave de acesso"
                        />
                    </div>

                    <div className="input-group">
                        <label>Nome da Inst√¢ncia</label>
                        <input
                            type="text"
                            value={localConfig.instanceName}
                            onChange={e => setLocalConfig({ ...localConfig, instanceName: e.target.value })}
                        />
                    </div>

                    <div className="divider" style={{ height: '1px', background: 'rgba(255,255,255,0.1)', margin: '5px 0' }}></div>


                </div>

                <div className="modal-footer" style={{ marginTop: '20px' }}>
                    <button className="v3-btn secondary" onClick={onClose}>Cancelar</button>
                    <button className="v3-btn primary" onClick={handleSave} style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                        <Save size={18} /> Salvar Altera√ß√µes
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ConfigModal;


--- FILE: src/components/ConnectModal.jsx ---

import React, { useState, useEffect } from 'react';
import { X, RefreshCw, LogOut, QrCode } from 'lucide-react';
import { useStore } from '../store/useStore';
import WhatsAppService from '../services/whatsapp';
import { io } from 'socket.io-client';

const ConnectModal = ({ isOpen, onClose }) => {
    const { instanceName, isConnected, setIsConnected, apiUrl, apiKey } = useStore();
    const [qrCode, setQrCode] = useState(null);
    const [loading, setLoading] = useState(false);
    const [status, setStatus] = useState('checking');
    const [socket, setSocket] = useState(null);
    // FIX: Counter to force WebSocket recreation when clicking "Conectar" after logout
    const [connecting, setConnecting] = useState(0);

    const checkStatus = async () => {
        const s = await WhatsAppService.checkConnection();
        setStatus(s);
        setIsConnected(s === 'open');
        if (s === 'open') setQrCode(null);
    };

    useEffect(() => {
        if (isOpen) checkStatus();
    }, [isOpen]);

    // WebSocket connection for real-time QR code updates
    useEffect(() => {
        if (!isOpen || !instanceName || isConnected) {
            // Cleanup socket if modal closes or instance is connected
            if (socket) {
                socket.disconnect();
                setSocket(null);
            }
            return;
        }


        // Convert HTTPS/HTTP URL to WSS/WS
        const wsUrl = apiUrl.replace('https://', 'wss://').replace('http://', 'ws://');
        // Use global WebSocket endpoint (Evolution API v2.1.1 doesn't support instance namespaces)
        console.log('Connecting to WebSocket (global mode):', wsUrl);

        const newSocket = io(wsUrl, {
            transports: ['websocket'],
            path: '/socket.io',
            reconnection: true,
            reconnectionAttempts: 5
        });

        newSocket.on('connect', () => {
            console.log('‚úÖ WebSocket connected');
        });

        newSocket.on('qrcode.updated', (payload) => {
            // Filter events by instance name
            if (payload.instance !== instanceName) {
                console.log('‚è≠Ô∏è  QR Code for different instance, skipping:', payload.instance);
                return;
            }
            console.log('üì± QR Code received for', instanceName, ':', payload);

            // Evolution API sends: { event, instance, data: { qrcode: { base64: "..." } } }
            // Extract the nested data object
            const data = payload.data || payload; // payload.data has the actual QR info
            let qrCodeData = null;

            if (data.qrcode) {
                if (typeof data.qrcode === 'string') {
                    // Format 1: data.qrcode is the base64 string directly
                    qrCodeData = data.qrcode;
                } else if (data.qrcode.base64) {
                    // Format 2: data.qrcode.base64 (MOST COMMON)
                    qrCodeData = data.qrcode.base64;
                } else if (data.qrcode.pairingCode) {
                    // Format 3: Alternative pairing code format
                    console.log('Pairing code available:', data.qrcode.pairingCode);
                }
            } else if (data.base64) {
                // Format 4: data.base64 directly
                qrCodeData = data.base64;
            }

            if (qrCodeData) {
                // Remove data URI prefix if present, then add it back to ensure consistency
                const base64Clean = qrCodeData.replace(/^data:image\/[a-z]+;base64,/, '');
                setQrCode(`data:image/png;base64,${base64Clean}`);
                console.log('‚úÖ QR Code set! Length:', base64Clean.length);
            } else {
                console.warn('‚ö†Ô∏è QR Code data received but format not recognized. Payload:', payload, 'Data:', data);
            }
        });

        newSocket.on('connection.update', (data) => {
            // Filter events by instance name
            if (data.instance !== instanceName) {
                return;
            }
            console.log('üîÑ Connection update:', data);
            if (data.state === 'open') {
                setQrCode(null);
                setIsConnected(true);
                checkStatus();
            }
        });

        newSocket.on('connect_error', (error) => {
            console.error('‚ùå WebSocket connection error:', error);
        });

        newSocket.on('disconnect', (reason) => {
            console.log('üîå WebSocket disconnected:', reason);
        });

        setSocket(newSocket);

        return () => {
            if (newSocket) {
                newSocket.disconnect();
            }
        };
    }, [isOpen, instanceName, isConnected, apiUrl, loading, connecting]); // FIX: Added loading and connecting to dependencies

    // Debug state
    const [debugInfo, setDebugInfo] = useState({ error: null, lastResponse: null });

    // START POLLING for QR Code if WebSocket fails
    useEffect(() => {
        if (!isOpen || isConnected || !instanceName) return;

        let pollInterval;
        const pollQrCode = async () => {
            if (qrCode) return; // Don't poll if we already have one
            try {
                console.log('üîÑ Polling: Checking for QR Code...');
                // Fetch the connection status/QR code directly
                const data = await WhatsAppService.connectInstance();
                setDebugInfo(prev => ({ ...prev, lastResponse: JSON.stringify(data).slice(0, 100) + '...' }));

                if (data && (data.qrcode || data.base64)) {
                    console.log('‚úÖ Polling: QR Code received via HTTP');
                    const raw = data.qrcode?.base64 || data.base64 || data.qrcode;
                    if (raw && typeof raw === 'string') {
                        const base64Clean = raw.replace(/^data:image\/[a-z]+;base64,/, '');
                        setQrCode(`data:image/png;base64,${base64Clean}`);
                        setStatus('open'); // Assume open if we got data (or at least responding)
                    }
                }
            } catch (e) {
                console.warn('Polling error:', e);
                setDebugInfo(prev => ({ ...prev, error: e.message }));
            }
        };

        // Start polling after 2 seconds to give WebSocket a chance first
        const timer = setTimeout(() => {
            console.log('‚ö†Ô∏è WebSocket slow/failed, starting HTTP polling for QR Code...');
            pollQrCode(); // Initial poll
            pollInterval = setInterval(pollQrCode, 3000);
        }, 2000);

        return () => {
            clearTimeout(timer);
            if (pollInterval) clearInterval(pollInterval);
        };
    }, [isOpen, isConnected, instanceName, qrCode]);

    const handleConnect = async () => {
        setLoading(true);
        setQrCode(null);
        setDebugInfo({ error: null, lastResponse: 'Restarting...' });

        // FIX: Force WebSocket useEffect to re-run by incrementing counter
        setConnecting(prev => prev + 1);
        try {
            // Restart instance to trigger new QR code generation
            // The QR code will be received via WebSocket qrcode.updated event OR Polling
            const response = await fetch(`${apiUrl}/instance/restart/${instanceName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': apiKey
                }
            });
            console.log('Instance restart triggered, waiting for QR code...');
        } catch (e) {
            console.error("Connect Error:", e);
            setDebugInfo(prev => ({ ...prev, error: e.message || 'Connect Failed' }));
        }
        setLoading(false);
    };

    const handleLogout = async () => {
        if (!window.confirm("Deseja realmente desconectar o WhatsApp? Isso apagar√° todos os dados locais.")) return;
        setLoading(true);
        try {
            // 1. Try to delete the instance on backend
            await WhatsAppService.logoutInstance();
        } catch (e) {
            console.error("Logout backend failed:", e);
        }

        // 2. Kill local session data immediately
        useStore.getState().logout();

        // 3. NUCLEAR OPTION: Clear all storage and FORCE RELOAD
        // This guarantees no React state or Zustand persistence survives
        localStorage.clear();
        sessionStorage.clear();

        setTimeout(() => {
            window.location.reload();
        }, 500);
    };

    if (!isOpen) return null;

    return (
        <div className="modal-overlay" onClick={onClose} style={{ backdropFilter: 'blur(10px)', backgroundColor: 'rgba(255,255,255,0.1)' }}>
            <div className="modal-content glass-panel" style={{ width: '450px', background: '#FFFFFF', border: '1px solid rgba(0,0,0,0.05)', padding: '0', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.1)' }} onClick={e => e.stopPropagation()}>
                <div className="modal-header" style={{ padding: '25px 30px', borderBottom: '1px solid rgba(0,0,0,0.05)' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                        <div style={{ background: 'var(--accent-primary)', padding: '8px', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                            <QrCode size={20} color="white" />
                        </div>
                        <h3 style={{ margin: 0, color: '#1d1d1f', fontSize: '18px', fontWeight: 'bold' }}>Conex√£o WhatsApp</h3>
                    </div>
                    <X size={24} onClick={onClose} style={{ cursor: 'pointer', opacity: 0.3 }} />
                </div>

                <div className="connection-body" style={{ padding: '40px', textAlign: 'center' }}>

                    {isConnected ? (
                        <div style={{ textAlign: 'center' }}>
                            <div style={{
                                display: 'inline-flex',
                                alignItems: 'center',
                                gap: '10px',
                                padding: '10px 25px',
                                background: '#F0FFF4',
                                color: '#276749',
                                borderRadius: '100px',
                                fontSize: '13px',
                                fontWeight: 'bold',
                                border: '1px solid #C6F6D5',
                                marginBottom: '35px'
                            }}>
                                <div style={{ width: '8px', height: '8px', background: '#38A169', borderRadius: '50%', boxShadow: '0 0 10px rgba(56, 161, 105, 0.4)' }}></div>
                                CONECTADO
                                <RefreshCw size={14} style={{ cursor: 'pointer', opacity: 0.5 }} className={status === 'connecting' ? 'spin' : ''} onClick={checkStatus} />
                            </div>

                            <div style={{ marginBottom: '40px' }}>
                                <p style={{ color: '#86868b', margin: '0 0 10px 0', fontSize: '14px' }}>Inst√¢ncia Ativa</p>
                                <p style={{ color: '#1d1d1f', margin: 0, fontSize: '24px', fontWeight: 'bold' }}>{instanceName}</p>
                            </div>

                            <button
                                onClick={handleLogout}
                                style={{
                                    background: '#FFF5F5',
                                    color: '#E53E3E',
                                    border: '1px solid #FED7D7',
                                    padding: '15px 40px',
                                    borderRadius: '50px',
                                    fontSize: '14px',
                                    fontWeight: 'bold',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '10px',
                                    margin: '0 auto',
                                    transition: 'all 0.2s'
                                }}
                                onMouseEnter={e => e.currentTarget.style.background = '#FED7D7'}
                                onMouseLeave={e => e.currentTarget.style.background = '#FFF5F5'}
                            >
                                <LogOut size={18} /> Desconectar WhatsApp
                            </button>
                        </div>
                    ) : (
                        <div>
                            {qrCode ? (
                                <div style={{ padding: '20px', background: 'white', borderRadius: '24px', border: '1px solid #E5E5E7' }}>
                                    <img src={qrCode} alt="QR Code" style={{ width: '100%', borderRadius: '12px' }} />
                                    <p style={{ marginTop: '20px', color: '#1d1d1f', fontWeight: 'bold', fontSize: '14px' }}>Escaneie para conectar</p>
                                </div>
                            ) : (
                                <div style={{ padding: '20px' }}>
                                    <p style={{ color: '#86868b', fontSize: '14px', marginBottom: '30px' }}>Gere um novo QR Code para autenticar sua sess√£o do WhatsApp.</p>
                                    <button className="btn-primary" style={{ width: '100%', padding: '16px', borderRadius: '16px' }} onClick={handleConnect} disabled={loading}>
                                        {loading ? 'Preparando...' : 'Gerar QR Code Agora'}
                                    </button>
                                </div>
                            )}
                        </div>
                    )}

                    {/* LOGS SECTION - CLEAN */}
                    <div style={{ marginTop: '40px', borderTop: '1px solid rgba(0,0,0,0.05)', paddingTop: '20px', textAlign: 'left' }}>
                        <details style={{ cursor: 'pointer' }}>
                            <summary style={{ color: '#86868b', fontSize: '11px', fontWeight: 'bold' }}>DETALHES T√âCNICOS</summary>
                            <div style={{ marginTop: '15px', padding: '15px', background: '#F9F9FA', borderRadius: '12px', fontSize: '11px', color: '#4a4a4c', fontFamily: 'monospace' }}>
                                STATUS: {status.toUpperCase()}<br />
                                SOCKET: {socket?.connected ? 'ONLINE' : 'OFFLINE'}<br />
                                INSTANCE: {instanceName}<br />
                                LOG: {debugInfo.lastResponse || 'None'}
                            </div>
                        </details>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default ConnectModal;


--- FILE: src/components/DashboardView.jsx ---

import React from 'react';
import { useStore } from '../store/useStore';
import { DollarSign, Users, TrendingUp, Activity } from 'lucide-react';

const DashboardView = () => {
    const { chats, chatTags, tags } = useStore();

    // CALCULATE METRICS
    const totalLeads = chats.length;

    // Revenue Estimate (Mock: Assume all 'Fechado' are Pro plans for now)
    const closedTagId = tags.find(t => t.name === 'Fechado' || t.name === 'Closed')?.id;
    const closedChats = chats.filter(c => {
        const jid = c.remoteJid || c.jid || c.id;
        return chatTags[jid] === closedTagId;
    });

    const revenue = closedChats.length * 397; // Assuming Pro Plan Ticket
    const conversionRate = totalLeads > 0 ? ((closedChats.length / totalLeads) * 100).toFixed(1) : 0;

    const cards = [
        { title: 'Faturamento Estimado', value: `R$ ${revenue.toLocaleString()}`, icon: <DollarSign color="#C5A059" />, sub: 'Baseado em vendas fechadas' },
        { title: 'Total de Leads', value: totalLeads, icon: <Users color="#1d1d1f" />, sub: 'Todos os canais' },
        { title: 'Taxa de Convers√£o', value: `${conversionRate}%`, icon: <TrendingUp color="#28a745" />, sub: `De ${totalLeads} leads` },
        { title: 'Leads Ativos', value: chats.length - closedChats.length, icon: <Activity color="#007bff" />, sub: 'Em negocia√ß√£o' }
    ];

    return (
        <div style={{ padding: '30px', height: '100%', overflowY: 'auto' }}>
            <h1 style={{ fontSize: '24px', marginBottom: '30px', color: '#1d1d1f' }}>Dashboard Comercial</h1>

            {/* KPI Cards */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(240px, 1fr))', gap: '20px', marginBottom: '40px' }}>
                {cards.map((card, i) => (
                    <div key={i} className="glass-panel" style={{ padding: '25px', display: 'flex', flexDirection: 'column', gap: '10px' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <span style={{ fontSize: '14px', color: '#86868b', fontWeight: '600' }}>{card.title}</span>
                            <div style={{ padding: '10px', background: 'rgba(0,0,0,0.03)', borderRadius: '12px' }}>{card.icon}</div>
                        </div>
                        <span style={{ fontSize: '28px', fontWeight: '800', color: '#1d1d1f' }}>{card.value}</span>
                        <span style={{ fontSize: '12px', color: '#86868b' }}>{card.sub}</span>
                    </div>
                ))}
            </div>

            {/* Performance Chart Placeholder */}
            <div className="glass-panel" style={{ padding: '30px', marginBottom: '30px', height: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center', border: '1px dashed #e0e0e0' }}>
                <p style={{ color: '#86868b' }}>Gr√°fico de Desempenho (Em Breve)</p>
            </div>

            {/* Recent Activity (New Leads) */}
            <div className="glass-panel" style={{ padding: '30px' }}>
                <h3 style={{ marginBottom: '20px', fontSize: '16px' }}>Leads Recentes</h3>
                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                        <tr style={{ borderBottom: '1px solid #eee' }}>
                            <th style={{ textAlign: 'left', padding: '10px', fontSize: '12px', color: '#86868b' }}>Nome</th>
                            <th style={{ textAlign: 'left', padding: '10px', fontSize: '12px', color: '#86868b' }}>Status</th>
                            <th style={{ textAlign: 'left', padding: '10px', fontSize: '12px', color: '#86868b' }}>Origem</th>
                        </tr>
                    </thead>
                    <tbody>
                        {chats.slice(0, 5).map(chat => {
                            const jid = chat.remoteJid || chat.id;
                            const tagId = chatTags[jid];
                            const tag = tags.find(t => t.id === tagId);
                            return (
                                <tr key={jid} style={{ borderBottom: '1px solid #f9f9fa' }}>
                                    <td style={{ padding: '15px 10px', fontSize: '14px', fontWeight: '500' }}>{chat.name || 'Desconhecido'}</td>
                                    <td style={{ padding: '15px 10px' }}>
                                        {tag ? (
                                            <span style={{ background: tag.color + '20', color: tag.color, padding: '5px 10px', borderRadius: '12px', fontSize: '11px', fontWeight: 'bold' }}>
                                                {tag.name}
                                            </span>
                                        ) : <span style={{ fontSize: '11px', opacity: 0.5 }}>Sem Status</span>}
                                    </td>
                                    <td style={{ padding: '15px 10px', fontSize: '12px', color: '#86868b' }}>
                                        {chat.__source === 'landing_page' ? 'üåê Web' : 'üì± WhatsApp'}
                                    </td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default DashboardView;


--- FILE: src/components/HistoryView.jsx ---

import React, { useState } from 'react';
import { Search, Archive } from 'lucide-react';
import { useStore } from '../store/useStore';
import { formatJid } from '../utils/formatter';

const HistoryView = () => {
    const { chats, setActiveChat, activeChat } = useStore();
    const [searchTerm, setSearchTerm] = useState('');

    // Get archived chat IDs from localStorage
    const archivedChatIds = JSON.parse(localStorage.getItem('archived_chats') || '[]');

    // Filter chats to show only archived ones
    const archivedChats = (Array.isArray(chats) ? chats : [])
        .filter(c => {
            const jid = c.remoteJid || c.jid || c.id;
            return archivedChatIds.includes(jid);
        })
        .filter(c => {
            if (!searchTerm) return true;
            const jidStr = String(c.remoteJid || c.jid || c.id || "").toLowerCase();
            const name = String(c.name || c.pushName || c.verifiedName || "").toLowerCase();
            const term = searchTerm.toLowerCase().trim();
            return name.includes(term) || jidStr.includes(term);
        })
        .sort((a, b) => {
            const tsA = a.lastMessage?.messageTimestamp || a.messageTimestamp || 0;
            const tsB = b.lastMessage?.messageTimestamp || b.messageTimestamp || 0;
            return (tsB * 1000) - (tsA * 1000);
        });

    return (
        <div className="chat-list-container glass-panel">
            <div className="list-header">
                <h2>Hist√≥rico</h2>
                <Archive size={20} style={{ color: 'var(--accent-primary)' }} />
            </div>

            <div className="search-bar">
                <Search size={16} />
                <input
                    type="text"
                    placeholder="Buscar no hist√≥rico..."
                    value={searchTerm}
                    onChange={e => setSearchTerm(e.target.value)}
                />
            </div>

            <div className="chats scrollable">
                {archivedChats.length === 0 ? (
                    <div className="empty-state" style={{ padding: '40px 20px', textAlign: 'center', opacity: 0.5 }}>
                        <Archive size={48} style={{ margin: '0 auto 15px', opacity: 0.3 }} />
                        <p style={{ fontSize: '14px', color: 'var(--text-muted)' }}>
                            {searchTerm ? 'Nenhum chat arquivado encontrado.' : 'Nenhum chat arquivado ainda.'}
                        </p>
                        <p style={{ fontSize: '12px', marginTop: '10px', color: 'var(--text-muted)' }}>
                            Use o bot√£o de arquivar nas conversas para mov√™-las para c√°.
                        </p>
                    </div>
                ) : (
                    archivedChats.map(chat => {
                        const jid = chat.remoteJid || chat.jid || chat.id;
                        const msg = chat.lastMessage?.message || chat.message || {};

                        let name = [
                            chat.name,
                            chat.pushName,
                            chat.verifiedName,
                            chat.lastMessage?.pushName,
                        ].find(n => n && n !== 'Voc√™' && !n.includes('@lid'));

                        let photo = chat.profilePicUrl || chat.profilePictureUrl || chat.profile || chat.avatar;
                        const hasName = name && name !== String(jid).split('@')[0];

                        return (
                            <div
                                key={String(jid)}
                                className={`chat-item ${activeChat?.id === jid ? 'active' : ''}`}
                                onClick={() => setActiveChat({ id: jid, name: name || formatJid(jid) })}
                            >
                                <div className="avatar">
                                    {photo ? (
                                        <img src={photo} alt={name || 'Avatar'} style={{ width: '100%', height: '100%', borderRadius: '50%', objectFit: 'cover' }} />
                                    ) : (
                                        (name || '#')[0]?.toUpperCase()
                                    )}
                                </div>
                                <div className="info">
                                    <div className="chat-main-header" style={{ display: 'flex', flexDirection: 'column', gap: '2px', alignItems: 'flex-start' }}>
                                        <h4 style={{ margin: 0, fontSize: '14px', fontWeight: 'bold', textAlign: 'left' }}>
                                            {hasName ? name : formatJid(jid)}
                                        </h4>
                                        {hasName && !jid.includes('@lid') && (
                                            <span style={{ fontSize: '11px', opacity: 0.6, fontWeight: '400', textAlign: 'left' }}>
                                                {formatJid(jid)}
                                            </span>
                                        )}
                                    </div>
                                    <p className="chat-preview">
                                        {(() => {
                                            const content = msg.conversation ||
                                                msg.extendedTextMessage?.text ||
                                                msg.imageMessage?.caption ||
                                                chat.lastMessage?.content || "";

                                            if (content) return content.length > 35 ? content.substring(0, 35) + "..." : content;

                                            if (msg.audioMessage) return "üéµ √Åudio";
                                            if (msg.imageMessage) return "üì∏ Imagem";
                                            if (msg.videoMessage) return "üé• V√≠deo";
                                            if (msg.documentMessage) return "üìÑ Documento";

                                            return formatJid(jid);
                                        })()}
                                    </p>
                                </div>
                            </div>
                        );
                    })
                )}
            </div>
        </div>
    );
};

export default HistoryView;


--- FILE: src/components/ImageViewer.jsx ---

import React, { useState, useEffect } from 'react';
import { Image as ImageIcon } from 'lucide-react';
import WhatsAppService from '../services/whatsapp';

const ImageViewer = ({ messageKey, caption }) => {
    const [imageUrl, setImageUrl] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const loadImage = async () => {
            try {
                const base64Data = await WhatsAppService.fetchMediaUrl(messageKey);
                if (base64Data) {
                    setImageUrl(base64Data);
                }
            } catch (e) {
                console.error("Image load error:", e);
            } finally {
                setLoading(false);
            }
        };

        if (messageKey) {
            loadImage();
        }
    }, [messageKey]);

    if (loading) {
        return (
            <div className="image-message loading">
                <ImageIcon size={16} color="#00ff88" />
                <span style={{ fontSize: '12px', marginLeft: '8px' }}>Carregando imagem...</span>
            </div>
        );
    }

    if (!imageUrl) {
        return <span>(Imagem üì∏)</span>;
    }

    return (
        <div className="image-message">
            <img
                src={imageUrl}
                alt="Imagem do cliente"
                style={{
                    maxWidth: '300px',
                    maxHeight: '300px',
                    borderRadius: '8px',
                    display: 'block'
                }}
            />
            {caption && <p style={{ marginTop: '8px', fontSize: '14px' }}>{caption}</p>}
        </div>
    );
};

export default ImageViewer;


--- FILE: src/components/LoginScreen.css ---

/* ========================================
   Login Screen - Gray Scale + Gold Theme
   ======================================== */

.login-container {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    /* CHANGED: Gray gradient instead of purple */
    background: linear-gradient(135deg, #F5F5F5 0%, #E0E0E0 100%);
    padding: 20px;
}

.login-card {
    background: white;
    border-radius: 20px;
    padding: 48px 40px;
    /* CHANGED: Subtle shadow with gray */
    box-shadow: 0 20px 60px rgba(44, 44, 44, 0.15);
    max-width: 420px;
    width: 100%;
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.login-header {
    text-align: center;
    margin-bottom: 40px;
}

.logo {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    background: transparent;
    margin-bottom: 20px;
}

.login-header h1 {
    font-size: 32px;
    font-weight: 700;
    margin: 0 0 8px 0;
    /* CHANGED: Dark gray text instead of gradient */
    color: #2C2C2C;
}

.subtitle {
    color: #9E9E9E;
    font-size: 14px;
    margin: 0;
}

.login-form {
    margin-bottom: 24px;
}

.form-group {
    margin-bottom: 24px;
}

.form-group label {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: #2C2C2C;
    margin-bottom: 8px;
}

.form-group input {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #E0E0E0;
    border-radius: 12px;
    font-size: 16px;
    transition: all 0.2s;
    background: #F9F9F9;
}

.form-group input:focus {
    outline: none;
    /* CHANGED: Gold border on focus */
    border-color: #D4AF37;
    background: white;
    /* CHANGED: Gold shadow */
    box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.form-group input:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.error-message {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background: #fee2e2;
    border: 1px solid #fecaca;
    border-radius: 12px;
    color: #991b1b;
    font-size: 14px;
    margin-bottom: 20px;
    animation: shake 0.3s;
}

@keyframes shake {

    0%,
    100% {
        transform: translateX(0);
    }

    25% {
        transform: translateX(-5px);
    }

    75% {
        transform: translateX(5px);
    }
}

.login-button {
    width: 100%;
    padding: 14px 24px;
    /* CHANGED: Gold gradient button */
    background: linear-gradient(135deg, #D4AF37 0%, #C19B2E 100%);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.login-button:hover:not(:disabled) {
    transform: translateY(-2px);
    /* CHANGED: Gold shadow on hover */
    box-shadow: 0 10px 20px rgba(212, 175, 55, 0.3);
}

.login-button:active:not(:disabled) {
    transform: translateY(0);
}

.login-button:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}

.spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

.login-footer {
    text-align: center;
    padding-top: 24px;
    border-top: 1px solid #E0E0E0;
}

.login-footer p {
    color: #9E9E9E;
    font-size: 14px;
    margin: 0;
}

/* REMOVED DARK MODE - Always use light gray palette */

--- FILE: src/components/LoginScreen.jsx ---

import { useState } from 'react';
import logoLight from '../assets/logo-light.png';
import logoDark from '../assets/logo-dark.png';
import './LoginScreen.css';

export default function LoginScreen({ onLogin }) {
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    const handleSubmit = (e) => {
        e.preventDefault();
        setError('');
        setIsLoading(true);

        // Get password from environment variable
        const correctPassword = import.meta.env.VITE_AUTH_PASSWORD || 'VoxeFlow2024!';
        console.log('AURA Login Debug:', {
            envSet: !!import.meta.env.VITE_AUTH_PASSWORD,
            expectedLength: correctPassword.length,
            match: password === correctPassword
        });

        setTimeout(() => {
            if (password === correctPassword) {
                // Store authentication token
                const token = btoa(`authenticated:${Date.now()}`);
                localStorage.setItem('auth_token', token);
                onLogin();
            } else {
                setError('Senha incorreta. Tente novamente.');
                setPassword('');
            }
            setIsLoading(false);
        }, 500);
    };

    return (
        <div className="login-container">
            <div className="login-card">
                <div className="login-header">
                    <div className="logo" style={{ marginBottom: '20px' }}>
                        <img src={logoDark} alt="AURA Logo" style={{ width: '120px', height: 'auto' }} />
                    </div>

                </div>

                <form onSubmit={handleSubmit} className="login-form">
                    <div className="form-group">
                        <label htmlFor="password">Senha de Acesso</label>
                        <input
                            id="password"
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            placeholder="Digite sua senha"
                            disabled={isLoading}
                            autoFocus
                            required
                        />
                    </div>

                    {error && (
                        <div className="error-message">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" />
                                <path d="M12 8V12" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
                                <circle cx="12" cy="16" r="1" fill="currentColor" />
                            </svg>
                            {error}
                        </div>
                    )}

                    <button
                        type="submit"
                        className="login-button"
                        disabled={isLoading || !password}
                    >
                        {isLoading ? (
                            <>
                                <span className="spinner"></span>
                                Validando...
                            </>
                        ) : (
                            'Entrar'
                        )}
                    </button>
                </form>

                <div className="login-footer">
                    <p>Protected by VoxeFlow Security</p>
                    <p style={{ fontSize: '10px', opacity: 0.5, marginTop: '5px' }}>v1.3.0 (Stable)</p>
                </div>
            </div>
        </div>
    );
}


--- FILE: src/components/MessageList.jsx ---

import React from 'react';
import AudioPlayer from './AudioPlayer';
import ImageViewer from './ImageViewer';
import { resolveRenderedMessage } from '../utils/chatArea';
import { formatMessageTime, getMessageDateGroup } from '../utils/formatter';

const MessageList = ({ messages, loading, messagesEndRef }) => {
    // Determine sort order. Assuming 'messages' prop is Newest-First (standard for chat apps storage),
    // we reverse it for display (Oldest at top, Newest at bottom).
    const sortedMessages = Array.isArray(messages) ? [...messages].reverse() : [];
    let lastDateGroup = null;

    return (
        <div className="thread scrollable">
            {sortedMessages.map((message, index) => {
                const parsed = resolveRenderedMessage(message);
                let displayContent = parsed.displayContent;
                let mediaElement = null;

                if (parsed.mediaType === 'audio') {
                    mediaElement = (
                        <div className="audio-message">
                            <AudioPlayer messageKey={message.key} />
                            {parsed.transcription && (
                                <p className="transcription" style={{ marginTop: '8px', fontSize: '12px', opacity: 0.8 }}>
                                    üéµ {parsed.transcription}
                                </p>
                            )}
                        </div>
                    );
                } else if (parsed.mediaType === 'image') {
                    mediaElement = <ImageViewer messageKey={message.key} caption={parsed.imageCaption} />;
                }

                if (!displayContent && !mediaElement && !message.key) return null;
                const messageKey = message?.key?.id || `${message?.messageTimestamp || 'ts'}-${index}`;
                const isFromMe = Boolean(message?.key?.fromMe || message?.fromMe);

                // Date Grouping Logic
                const messageDate = getMessageDateGroup(message.messageTimestamp);
                const showDateSeparator = messageDate !== lastDateGroup;
                lastDateGroup = messageDate;

                // Time Formatting
                const formattedTime = formatMessageTime(message.messageTimestamp);

                return (
                    <React.Fragment key={messageKey}>
                        {showDateSeparator && (
                            <div className="date-separator">
                                <span>{messageDate}</span>
                            </div>
                        )}
                        <div className={`message ${isFromMe ? 'out' : 'in'}`}>
                            {mediaElement || displayContent}
                            <span className="msg-time">{formattedTime}</span>
                        </div>
                    </React.Fragment>
                );
            })}
            {loading && messages.length === 0 && <p className="loading-txt">Carregando hist√≥rico...</p>}
            <div ref={messagesEndRef} />
        </div>
    );
};

export default MessageList;


--- FILE: src/components/Sidebar.jsx ---

import { X, LayoutDashboard, Kanban, History, Settings, LogOut, Brain, Zap } from 'lucide-react';
import { useStore } from '../store/useStore';
import logoLight from '../assets/logo-light.png';
import logoDark from '../assets/logo-dark.png';

const Sidebar = ({ onOpenConfig, onOpenConnect, onOpenBriefing, onLogout, isOpen, onClose }) => {
    const { activeChat, currentView, setCurrentView, setActiveChat, switchView } = useStore();
    return (
        <>
            {/* Mobile Overlay */}
            <div className={`sidebar-overlay ${isOpen ? 'open' : ''}`} onClick={onClose} />

            <aside className={`sidebar glass-panel ${isOpen ? 'mobile-open' : ''}`}>
                <button className="mobile-close-btn" onClick={onClose}>
                    <X size={24} />
                </button>
                <div className="logo-container" style={{ padding: '20px 0', textAlign: 'center' }}>
                    <img src={logoLight} alt="AURA" style={{ width: '80%', maxWidth: '120px', height: 'auto' }} />
                </div>

                <nav id="mainNav">
                    <ul>
                        <li className={currentView === 'dashboard' ? 'active' : ''} onClick={() => switchView('dashboard')} title="Dashboard">
                            <LayoutDashboard size={24} />
                        </li>
                        <li className={currentView === 'crm' ? 'active' : ''} onClick={() => switchView('crm')} title="CRM Pipeline">
                            <Kanban size={24} />
                        </li>
                        <li className={currentView === 'history' ? 'active' : ''} onClick={() => switchView('history')} title="Hist√≥rico">
                            <History size={24} />
                        </li>
                    </ul>
                </nav>

                <div className="sidebar-footer">
                    <div style={{ padding: '10px 0', width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px' }}>
                        <div
                            title="AURA Brain"
                            onClick={onOpenBriefing}
                            className="sidebar-action-btn"
                            style={{
                                cursor: 'pointer',
                                padding: '10px',
                                borderRadius: '12px',
                                color: 'var(--accent-primary)',
                                transition: 'all 0.3s',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                background: 'rgba(197, 160, 89, 0.1)'
                            }}
                        >
                            <Brain size={22} />
                        </div>

                        <div
                            title="Conex√£o WhatsApp"
                            onClick={onOpenConnect}
                            className="sidebar-action-btn"
                            style={{
                                cursor: 'pointer',
                                padding: '10px',
                                borderRadius: '12px',
                                color: 'var(--text-muted)',
                                transition: 'all 0.3s',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center'
                            }}
                            onMouseEnter={e => { e.currentTarget.style.color = 'var(--accent-primary)'; e.currentTarget.style.background = 'rgba(197, 160, 89, 0.1)'; }}
                            onMouseLeave={e => { e.currentTarget.style.color = 'var(--text-muted)'; e.currentTarget.style.background = 'transparent'; }}
                        >
                            <Zap size={22} />
                        </div>

                        <div
                            title="Configura√ß√µes Aura"
                            onClick={onOpenConfig}
                            className="sidebar-action-btn"
                            style={{
                                cursor: 'pointer',
                                padding: '10px',
                                borderRadius: '12px',
                                color: 'var(--text-muted)',
                                transition: 'all 0.3s',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center'
                            }}
                            onMouseEnter={e => { e.currentTarget.style.color = 'var(--accent-primary)'; e.currentTarget.style.background = 'rgba(197, 160, 89, 0.1)'; }}
                            onMouseLeave={e => { e.currentTarget.style.color = 'var(--text-muted)'; e.currentTarget.style.background = 'transparent'; }}
                        >
                            <Settings size={22} />
                        </div>

                        <button
                            onClick={onLogout}
                            className="logout-button"
                            title="Sair"
                            style={{ background: 'none', border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '10px', width: '100%', color: 'var(--text-muted)', transition: 'color 0.2s' }}
                            onMouseEnter={(e) => e.target.style.color = '#ff4d4d'}
                            onMouseLeave={(e) => e.target.style.color = 'var(--text-muted)'}
                        >
                            <LogOut size={20} />
                        </button>

                        <div style={{ fontSize: '10px', opacity: 0.3, marginTop: '10px', color: 'var(--text-muted)' }}>
                            v12.0-beta
                        </div>

                        <div className="conn-status" style={{ fontSize: '8px', opacity: 0.3, marginTop: '2px', textAlign: 'center', wordBreak: 'break-all', padding: '0 5px' }}>
                            {activeChat?.id ? activeChat.id : ''}
                        </div>
                    </div>
                </div>
            </aside>
        </>
    );
};

export default Sidebar;


--- FILE: src/components/TagSelectorDialogContent.jsx ---

const TagSelectorDialogContent = ({ tags }) => {
    return (
        <div style={{ marginTop: '15px' }}>
            <label
                style={{
                    display: 'block',
                    marginBottom: '8px',
                    color: '#ffffff',
                    fontSize: '14px',
                    fontWeight: '500',
                }}
            >
                Selecione o est√°gio do lead:
            </label>
            <select
                id="tagSelect"
                style={{
                    width: '100%',
                    padding: '12px',
                    borderRadius: '8px',
                    border: '1px solid #475569',
                    background: '#1e293b',
                    color: '#ffffff',
                    fontSize: '14px',
                    cursor: 'pointer',
                    outline: 'none',
                }}
            >
                <option value="" style={{ color: '#94a3b8' }}>
                    Selecione uma tag...
                </option>
                {tags.map((tag) => (
                    <option key={tag.id} value={tag.id} style={{ color: '#ffffff' }}>
                        {tag.icon} {tag.name}
                    </option>
                ))}
            </select>
        </div>
    );
};

export default TagSelectorDialogContent;


--- FILE: src/hooks/useArchivedChats.js ---

import { useCallback, useEffect, useState } from 'react';
import { ARCHIVED_CHATS_CHANGED_EVENT, getArchivedChats } from '../utils/chatStorage';

export function useArchivedChats() {
    const [archivedChatIds, setArchivedChatIds] = useState(() => getArchivedChats());

    const refreshArchivedChats = useCallback(() => {
        setArchivedChatIds(getArchivedChats());
    }, []);

    useEffect(() => {
        window.addEventListener('storage', refreshArchivedChats);
        window.addEventListener(ARCHIVED_CHATS_CHANGED_EVENT, refreshArchivedChats);

        return () => {
            window.removeEventListener('storage', refreshArchivedChats);
            window.removeEventListener(ARCHIVED_CHATS_CHANGED_EVENT, refreshArchivedChats);
        };
    }, [refreshArchivedChats]);

    return archivedChatIds;
}


--- FILE: src/hooks/useBriefingLogic.js ---

import { useState } from 'react';
import OpenAIService from '../services/openai';

const INITIAL_QUESTION = 'Para come√ßarmos: Qual o nome da sua empresa e o que exatamente voc√™s fazem?';

export function useBriefingLogic({ knowledgeBase, setKnowledgeBase, setConfig }) {
    const [view, setView] = useState('dashboard');
    const [status, setStatus] = useState('idle');
    const [currentQuestion, setCurrentQuestion] = useState(INITIAL_QUESTION);
    const [currentAnswer, setCurrentAnswer] = useState('');
    const [lastAnalysis, setLastAnalysis] = useState('');
    const [editingId, setEditingId] = useState(null);
    const [tempAnswer, setTempAnswer] = useState('');

    const syncBriefingText = (kb) => {
        const currentKB = kb || [];
        const text = currentKB.map((item) => `[P]: ${item.q}\n[R]: ${item.a}`).join('\n\n');
        setConfig({ briefing: text });
    };

    const handleNextInterview = async () => {
        if (!currentAnswer.trim()) return;

        setStatus('thinking');
        try {
            const analysis = await OpenAIService.analyzeKnowledgePoint(currentQuestion, currentAnswer);
            setLastAnalysis(analysis);

            const newItem = {
                id: Date.now(),
                q: currentQuestion,
                a: currentAnswer,
                analysis,
            };

            const currentKB = knowledgeBase || [];
            setKnowledgeBase([...currentKB, newItem]);
            setStatus('showing_analysis');
        } catch (error) {
            console.error('AURA: Error in interview step', error);
            setStatus('idle');
        }
    };

    const proceedToNext = async () => {
        setStatus('thinking');
        try {
            const nextQ = await OpenAIService.generateNextBriefingQuestion(knowledgeBase);

            if (nextQ.includes('COMPLETE') || knowledgeBase.length >= 10) {
                setStatus('idle');
                setView('dashboard');
                syncBriefingText(knowledgeBase);
            } else {
                setCurrentQuestion(nextQ);
                setCurrentAnswer('');
                setLastAnalysis('');
                setStatus('idle');
            }
        } catch {
            setStatus('idle');
        }
    };

    const handleUpdatePoint = async (id) => {
        const currentKB = knowledgeBase || [];
        const point = currentKB.find((item) => item.id === id);
        if (!point) return;

        setStatus('thinking');
        try {
            const analysis = await OpenAIService.analyzeKnowledgePoint(point.q, tempAnswer);
            const newKB = currentKB.map((item) =>
                item.id === id ? { ...item, a: tempAnswer, analysis } : item
            );
            setKnowledgeBase(newKB);
            syncBriefingText(newKB);
            setEditingId(null);
            setStatus('idle');
        } catch {
            setStatus('idle');
        }
    };

    const resetKnowledge = () => {
        setKnowledgeBase([]);
        setConfig({ briefing: '' });
        setView('interview');
        setStatus('idle');
        setCurrentQuestion(INITIAL_QUESTION);
        setCurrentAnswer('');
        setLastAnalysis('');
        setEditingId(null);
        setTempAnswer('');
    };

    return {
        view,
        setView,
        status,
        setStatus,
        currentQuestion,
        currentAnswer,
        setCurrentAnswer,
        lastAnalysis,
        editingId,
        setEditingId,
        tempAnswer,
        setTempAnswer,
        handleNextInterview,
        proceedToNext,
        handleUpdatePoint,
        resetKnowledge,
    };
}


--- FILE: src/hooks/useChatAI.js ---

import { useCallback, useState } from 'react';
import OpenAIService from '../services/openai';
import { buildStructuredHistory, deriveAnalysisData, getClientNameForAi, getLastClientText } from '../utils/chatArea';

export function useChatAI({ activeChat, messages, briefing, setInput }) {
    const [suggestion, setSuggestion] = useState('');
    const [analysisData, setAnalysisData] = useState({ level: '', intent: '', strategy: '' });
    const [isEnhancing, setIsEnhancing] = useState(false);

    const resetAiState = useCallback(() => {
        setSuggestion('');
        setAnalysisData({ level: '', intent: '', strategy: '' });
    }, []);

    const handleAnalyze = useCallback(async () => {
        if (!activeChat) return;

        const wandIcon = document.querySelector('.btn-primary.v3-btn svg');
        if (wandIcon) wandIcon.style.animation = 'spin 1s linear infinite';

        try {
            const clientName = getClientNameForAi(activeChat);
            const structuredHistory = buildStructuredHistory(messages);
            const lastClientText = getLastClientText(messages);

            setSuggestion('Aura Orquestrador v8.7: Sincronizando contexto completo v1.1.7...');

            const RAGService = (await import('../services/rag')).default;
            const extraContext = await RAGService.getRelevantContext(lastClientText);

            const aiRes = await OpenAIService.generateSuggestion({
                clientName,
                history: structuredHistory,
                extraContext,
                briefing: briefing || 'Neg√≥cio de Alto Padr√£o',
            });

            if (aiRes) {
                // AURA v11: Knowledge Gap Detection
                if (aiRes.includes('[KNOWLEDGE_GAP:')) {
                    const managerQuestion = aiRes.match(/\[KNOWLEDGE_GAP:\s*(.*?)]/)?.[1] || 'Pergunta n√£o identificada';
                    const { managerPhone, setConfig, pendingGaps } = useStore.getState();

                    if (managerPhone) {
                        setSuggestion(`üß† AURA identificou uma lacuna no c√©rebro. Consultando especialista atrav√©s do WhatsApp...`);

                        // Send message to manager
                        const WhatsAppService = (await import('../services/whatsapp')).default;
                        const managerMsg = `üö® *AURA: Nova D√∫vida de Lead*\n\nUm lead perguntou algo que n√£o sei responder.\n\n*Pergunta para voc√™:* ${managerQuestion}\n\n_Responda esta mensagem para atualizar meu c√©rebro automaticamente._`;

                        await WhatsAppService.sendMessage(managerPhone, managerMsg);

                        // Track pending gap
                        const gapId = `gap-${Date.now()}`;
                        setConfig({
                            pendingGaps: {
                                ...pendingGaps,
                                [managerPhone.replace(/\D/g, '')]: {
                                    id: gapId,
                                    chatId: activeChat.id,
                                    question: managerQuestion,
                                    timestamp: Date.now()
                                }
                            }
                        });
                    } else {
                        setSuggestion(`‚ö†Ô∏è AURA precisa saber: "${managerQuestion}". (Configure o telefone do gestor nas configura√ß√µes para automatizar isso).`);
                    }
                } else {
                    setAnalysisData(deriveAnalysisData(aiRes));
                    setSuggestion(aiRes.trim());
                }
            } else {
                setSuggestion('N√£o foi poss√≠vel gerar uma sugest√£o no momento. Tente novamente.');
            }
        } catch (error) {
            console.error('AURA Analysis Error:', error);
            setSuggestion(`Erro T√©cnico: ${error.message || 'Desconhecido'}`);
        } finally {
            if (wandIcon) wandIcon.style.animation = 'none';
        }
    }, [activeChat, briefing, messages]);

    const handleEnhance = useCallback(async (input) => {
        if (!input.trim() || isEnhancing) return;

        setIsEnhancing(true);
        const originalInput = input;
        setInput('‚ú® Aura refinando sua mensagem...');

        try {
            const enhanced = await OpenAIService.enhanceMessage(originalInput, { briefing });
            if (enhanced && enhanced !== originalInput) {
                setInput(enhanced);
            } else {
                setInput(originalInput);
            }
        } catch (error) {
            console.error('AURA Enhance Error:', error);
            setInput(originalInput);
        } finally {
            setIsEnhancing(false);
        }
    }, [briefing, isEnhancing, setInput]);

    return {
        suggestion,
        setSuggestion,
        analysisData,
        setAnalysisData,
        isEnhancing,
        resetAiState,
        handleAnalyze,
        handleEnhance,
    };
}


--- FILE: src/hooks/useChatActions.jsx ---

import { useCallback } from 'react';
import { useStore } from '../store/useStore';
import WhatsAppService from '../services/whatsapp';
import { archiveChat, unarchiveChat } from '../utils/chatStorage';
import TagSelectorDialogContent from '../components/TagSelectorDialogContent';

export function useChatActions({ activeChat, openConfirm, setActiveChat }) {
    const handleTag = useCallback(() => {
        const { setTag, tags } = useStore.getState();

        openConfirm(
            'Etiquetar Conversa',
            <TagSelectorDialogContent tags={tags} />,
            () => {
                const select = document.getElementById('tagSelect');
                const tagId = select?.value;

                if (!tagId) {
                    alert('‚ö†Ô∏è Selecione uma tag v√°lida!');
                    return;
                }

                setTag(activeChat.id, tagId);
                alert('‚úÖ Tag aplicada com sucesso!');
            }
        );
    }, [activeChat, openConfirm]);



    const handleUnarchive = useCallback(() => {
        const changed = unarchiveChat(activeChat.id);
        if (changed) {
            alert('‚úÖ Conversa desarquivada!');
        }
    }, [activeChat]);

    const handleArchive = useCallback(() => {
        const changed = archiveChat(activeChat.id);
        if (changed) {
            setActiveChat(null);
            alert('‚úÖ Conversa arquivada!');
        }
    }, [activeChat, setActiveChat]);

    return {
        handleTag,
        handleUnarchive,
        handleArchive,
    };
}


--- FILE: src/hooks/useChatComposer.js ---

import { useCallback, useRef, useState } from 'react';
import WhatsAppService from '../services/whatsapp';
import { useStore } from '../store/useStore';

export function useChatComposer({
    activeChat,
    input,
    setInput,
    suggestion,
    sending,
    setSending,
    loadMessages,
    setShowAttachMenu,
    openConfirm,
    openPrompt,
}) {
    const appendPendingOutgoing = useStore((state) => state.appendPendingOutgoing);
    const [recording, setRecording] = useState(false);
    const mediaRecorderRef = useRef(null);
    const audioChunksRef = useRef([]);

    const promptManualPhoneAndRetry = useCallback((jid, initialPhone, retryText, chatData) => {
        const initialDigits = String(initialPhone || '').replace(/\D/g, '');

        openPrompt(
            'Corrigir n√∫mero do contato',
            initialDigits,
            async (typedPhone) => {
                const normalized = String(typedPhone || '').replace(/\D/g, '');
                if (!/^\d{10,15}$/.test(normalized)) {
                    openConfirm('N√∫mero inv√°lido', 'Digite entre 10 e 15 n√∫meros (somente d√≠gitos).');
                    return;
                }

                const saved = WhatsAppService.setManualPhoneMapping(jid, normalized, chatData);
                if (!saved) {
                    openConfirm('Erro', 'N√£o foi poss√≠vel salvar o n√∫mero deste contato.');
                    return;
                }

                setSending(true);
                try {
                    const retry = await WhatsAppService.sendMessage(jid, retryText, chatData);
                    if (retry && !retry.error) {
                        appendPendingOutgoing(jid, retryText, retry);
                        setInput('');
                        loadMessages();
                        openConfirm('Sucesso', 'Mensagem enviada ap√≥s corrigir o n√∫mero.');
                        return;
                    }

                    const retryError = retry?.message || 'Falha ao reenviar ap√≥s corre√ß√£o.';
                    openConfirm('Falha no Reenvio', retryError);
                } catch (error) {
                    openConfirm('Erro', `Erro inesperado ao reenviar: ${error.message}`);
                } finally {
                    setSending(false);
                }
            }
        );
    }, [appendPendingOutgoing, loadMessages, openConfirm, openPrompt, setInput, setSending]);

    const handleMicClick = useCallback(async () => {
        if (!activeChat?.id) return;

        if (recording) {
            if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
                mediaRecorderRef.current.stop();
            }
            setRecording(false);
            return;
        }

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            mediaRecorderRef.current = mediaRecorder;
            audioChunksRef.current = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunksRef.current.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/mp4' });
                const audioFile = new File([audioBlob], 'voice_message.mp3', { type: 'audio/mp4' });

                setSending(true);
                try {
                    await WhatsAppService.sendMedia(activeChat.id, audioFile, '', true);
                    loadMessages();
                } catch (error) {
                    console.error('Audio Send Error:', error);
                    alert('‚ùå Erro ao enviar √°udio.');
                } finally {
                    setSending(false);
                }

                stream.getTracks().forEach((track) => track.stop());
            };

            mediaRecorder.start();
            setRecording(true);
        } catch (error) {
            console.error('Mic Access Error:', error);
            alert('‚ùå Erro ao acessar microfone. Verifique as permiss√µes.');
        }
    }, [activeChat?.id, loadMessages, recording, setSending]);

    const handleSend = useCallback(async (e) => {
        if (e) e.preventDefault();
        const jid = activeChat?.id;
        if (!input.trim() || sending || !jid) return;

        setSending(true);
        try {
            const res = await WhatsAppService.sendMessage(jid, input, activeChat);

            if (res && !res.error) {
                appendPendingOutgoing(jid, input, res);
                setInput('');
                await loadMessages();
                setTimeout(() => {
                    loadMessages();
                }, 1200);
            } else {
                const errorMsg = res?.message || 'Erro ao enviar mensagem';
                console.error('‚ùå Erro ao enviar:', errorMsg);

                if (res?.needsPhoneNumber) {
                    const suggested = res?.suggestedPhone || res?.attemptedPhone || '';
                    promptManualPhoneAndRetry(jid, suggested, input, activeChat);
                } else if (res?.invalidRecipient) {
                    openConfirm('N√∫mero indispon√≠vel', errorMsg);
                } else {
                    openConfirm('Falha no Envio', `${errorMsg}\n\nüí° Dica: Use o bot√£o de l√°pis (‚úèÔ∏è) no topo para corrigir o n√∫mero.`);
                }
            }
        } catch (error) {
            console.error('AURA Send Error:', error);
            openConfirm('Erro', `Erro inesperado: ${error.message}`);
        }
        setSending(false);
    }, [activeChat, appendPendingOutgoing, input, loadMessages, openConfirm, promptManualPhoneAndRetry, sending, setInput, setSending]);

    const useSuggestion = useCallback(() => {
        if (suggestion && !suggestion.includes('...')) {
            setInput(suggestion);
        }
    }, [setInput, suggestion]);

    const handleFileSelect = useCallback(async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // Reset the input so the same file can be selected again if needed
        e.target.value = '';

        setShowAttachMenu(false);

        openPrompt(`Enviar: ${file.name}`, '', async (caption) => {
            try {
                setSending(true);
                const res = await WhatsAppService.sendMedia(activeChat.id, file, caption || '');
                if (res) {
                    loadMessages();
                } else {
                    console.error('Upload failed result:', res);
                    openConfirm('Erro', 'Falha ao enviar arquivo.');
                }
            } catch (error) {
                console.error('Upload error:', error);
                openConfirm('Erro', 'Erro ao enviar m√≠dia.');
            } finally {
                setSending(false);
            }
        });
    }, [activeChat?.id, loadMessages, openConfirm, openPrompt, setSending, setShowAttachMenu]);

    // This now only handles the menu logic if needed, or can be removed if handled in UI
    const handleAttachmentMenuOpen = useCallback(() => {
        setShowAttachMenu(true);
    }, [setShowAttachMenu]);

    return {
        recording,
        handleMicClick,
        handleSend,
        useSuggestion,
        handleFileSelect,
        handleAttachmentMenuOpen,
    };
}


--- FILE: src/hooks/useChatDialogs.js ---

import { useCallback, useState } from 'react';

const INITIAL_DIALOG = {
    isOpen: false,
    type: '',
    title: '',
    message: '',
    onConfirm: null,
    inputPlaceholder: '',
};

export function useChatDialogs() {
    const [dialog, setDialog] = useState(INITIAL_DIALOG);
    const [dialogInput, setDialogInput] = useState('');

    const openConfirm = useCallback((title, message, onConfirm) => {
        setDialog({
            isOpen: true,
            type: 'confirm',
            title,
            message,
            onConfirm,
            inputPlaceholder: '',
        });
    }, []);

    const openPrompt = useCallback((title, initialValue, onConfirm) => {
        setDialogInput(initialValue || '');
        setDialog({
            isOpen: true,
            type: 'prompt',
            title,
            message: '',
            onConfirm,
            inputPlaceholder: 'Digite aqui...',
        });
    }, []);

    const handleDialogClose = useCallback(() => {
        setDialog((prev) => ({ ...prev, isOpen: false }));
        setDialogInput('');
    }, []);

    const handleDialogConfirm = useCallback(() => {
        if (dialog.onConfirm) {
            dialog.onConfirm(dialog.type === 'prompt' ? dialogInput : true);
        }
        handleDialogClose();
    }, [dialog, dialogInput, handleDialogClose]);

    return {
        dialog,
        dialogInput,
        setDialogInput,
        openConfirm,
        openPrompt,
        handleDialogClose,
        handleDialogConfirm,
    };
}


--- FILE: src/hooks/useChatThread.js ---

import { useCallback, useEffect, useRef, useState } from 'react';
import WhatsAppService from '../services/whatsapp';

export function useChatThread({ activeChat, messages, setMessages, clearMessages }) {
    const [loading, setLoading] = useState(false);
    const messagesEndRef = useRef(null);
    const activeJidRef = useRef(null);
    const isFirstLoadRef = useRef(true);

    const loadMessages = useCallback(async () => {
        const jid = activeChat?.id;
        if (!jid) return;

        setLoading(true);
        try {
            const linkedLid = activeChat.linkedLid || null;
            const data = await WhatsAppService.fetchMessages(jid, linkedLid, activeChat);
            if (activeJidRef.current === jid) {
                setMessages(jid, data || []);
            }
        } catch (error) {
            console.error('AURA ChatArea v6 Error:', error);
        } finally {
            setLoading(false);
        }
    }, [activeChat, setMessages]);

    useEffect(() => {
        if (isFirstLoadRef.current && messages.length > 0) {
            messagesEndRef.current?.scrollIntoView({ behavior: 'auto' });
            isFirstLoadRef.current = false;
        }
    }, [messages]);

    useEffect(() => {
        const jid = activeChat?.id;
        activeJidRef.current = jid;
        isFirstLoadRef.current = true;
        clearMessages();

        if (!jid) return;

        loadMessages();
        const interval = setInterval(loadMessages, 5000);
        return () => clearInterval(interval);
    }, [activeChat?.id, clearMessages, loadMessages]);

    return {
        loading,
        messagesEndRef,
        loadMessages,
    };
}


--- FILE: src/hooks/useKnowledgeLoop.js ---

import { useEffect } from 'react';
import { useStore } from '../store/useStore';
import OpenAIService from '../services/openai';
import WhatsAppService from '../services/whatsapp';

export function useKnowledgeLoop() {
    const {
        managerPhone,
        pendingGaps,
        knowledgeBase,
        setKnowledgeBase,
        setConfig,
        chats
    } = useStore();

    useEffect(() => {
        if (!managerPhone) return;

        // Custom event or polling logic to detect manager's response
        // In this implementation, we'll use a globally exposed handler 
        // that the App can call when a new message arrives.

        const handleNewManagerMessage = async (msg) => {
            const sender = msg.key.remoteJid?.replace(/\D/g, '') || '';
            const cleanManagerPhone = managerPhone.replace(/\D/g, '');

            if (sender !== cleanManagerPhone) return;

            const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';
            if (!text) return;

            console.log('AURA Loop: Manager response detected:', text);

            const gap = pendingGaps[cleanManagerPhone];
            if (gap) {
                console.log('AURA Loop: Resolving gap:', gap.question);

                try {
                    // 1. Analyze the manager's answer to create a clean point
                    const analysis = await OpenAIService.analyzeKnowledgePoint(gap.question, text);

                    const newItem = {
                        id: Date.now(),
                        q: gap.question,
                        a: text,
                        analysis
                    };

                    // 2. Update Knowledge Base
                    const newKB = [...(knowledgeBase || []), newItem];
                    setKnowledgeBase(newKB);

                    // 3. Sync Briefing Text
                    const briefingText = newKB.map(item => `[P]: ${item.q}\n[R]: ${item.a}`).join('\n\n');
                    setConfig({
                        briefing: briefingText,
                        // Clear the gap
                        pendingGaps: { ...pendingGaps, [cleanManagerPhone]: null }
                    });

                    // 4. (Optional) Auto-notify the original user that the answer is ready
                    // We'll leave this for the UI/User manual trigger for now to avoid spam
                    console.log('AURA Loop: Brain updated with new knowledge!');

                    // Dispatch event for UI feedback
                    window.dispatchEvent(new CustomEvent('aura-brain-updated', { detail: newItem }));

                } catch (error) {
                    console.error('AURA Loop: Error resolving knowledge gap:', error);
                }
            }
        };

        // Expose globally so the main socket listener can trigger it
        window.__aura_handle_manager_message = handleNewManagerMessage;

        return () => {
            delete window.__aura_handle_manager_message;
        };
    }, [managerPhone, pendingGaps, knowledgeBase, setKnowledgeBase, setConfig]);
}


--- FILE: src/hooks/useWhatsAppConnection.js ---

import { useCallback, useEffect, useRef, useState } from 'react';
import { io } from 'socket.io-client';
import { useStore } from '../store/useStore';
import WhatsAppService from '../services/whatsapp';
import { extractQrCodeBase64, toWsUrl } from '../utils/connectModal';

export function useWhatsAppConnection({
    isOpen,
    instanceName,
    isConnected,
    setIsConnected,
    apiUrl,
    apiKey,
}) {
    const [qrCode, setQrCode] = useState(null);
    const [loading, setLoading] = useState(false);
    const [status, setStatus] = useState('checking');
    const [debugInfo, setDebugInfo] = useState({ error: null, lastResponse: null });
    const [socketConnected, setSocketConnected] = useState(false);
    const [connecting, setConnecting] = useState(0);
    const socketRef = useRef(null);

    const checkStatus = useCallback(async () => {
        const nextStatus = await WhatsAppService.checkConnection();
        setStatus(nextStatus);
        setIsConnected(nextStatus === 'open');
        if (nextStatus === 'open') setQrCode(null);
    }, [setIsConnected]);

    useEffect(() => {
        if (isOpen) checkStatus();
    }, [isOpen, checkStatus]);

    useEffect(() => {
        if (!isOpen || !instanceName || isConnected || !apiUrl) {
            if (socketRef.current) {
                socketRef.current.disconnect();
                socketRef.current = null;
            }
            setSocketConnected(false);
            return;
        }

        const wsUrl = toWsUrl(apiUrl);
        const socket = io(wsUrl, {
            transports: ['websocket'],
            path: '/socket.io',
            reconnection: true,
            reconnectionAttempts: 5,
        });

        socket.on('connect', () => {
            setSocketConnected(true);
            console.log('‚úÖ WebSocket connected');
        });

        socket.on('qrcode.updated', (payload) => {
            if (payload.instance !== instanceName) return;
            const base64Clean = extractQrCodeBase64(payload);
            if (base64Clean) {
                setQrCode(`data:image/png;base64,${base64Clean}`);
            }
        });

        socket.on('connection.update', (data) => {
            if (data.instance !== instanceName) return;
            if (data.state === 'open') {
                setQrCode(null);
                setIsConnected(true);
                checkStatus();
            }
        });

        socket.on('connect_error', (error) => {
            console.error('‚ùå WebSocket connection error:', error);
        });

        socket.on('disconnect', () => {
            setSocketConnected(false);
        });

        socketRef.current = socket;

        return () => {
            socket.disconnect();
            setSocketConnected(false);
        };
    }, [isOpen, instanceName, isConnected, apiUrl, connecting, checkStatus, setIsConnected]);

    useEffect(() => {
        if (!isOpen || isConnected || !instanceName) return;

        let pollInterval;
        const pollQrCode = async () => {
            if (qrCode) return;
            try {
                const data = await WhatsAppService.connectInstance();
                setDebugInfo((prev) => ({ ...prev, lastResponse: JSON.stringify(data).slice(0, 100) + '...' }));

                if (data && (data.qrcode || data.base64)) {
                    const raw = data.qrcode?.base64 || data.base64 || data.qrcode;
                    if (raw && typeof raw === 'string') {
                        const base64Clean = raw.replace(/^data:image\/[a-z]+;base64,/, '');
                        setQrCode(`data:image/png;base64,${base64Clean}`);
                        setStatus('open');
                    }
                }
            } catch (error) {
                console.warn('Polling error:', error);
                setDebugInfo((prev) => ({ ...prev, error: error.message }));
            }
        };

        const timer = setTimeout(() => {
            pollQrCode();
            pollInterval = setInterval(pollQrCode, 3000);
        }, 2000);

        return () => {
            clearTimeout(timer);
            if (pollInterval) clearInterval(pollInterval);
        };
    }, [isOpen, isConnected, instanceName, qrCode]);

    const handleConnect = useCallback(async () => {
        setLoading(true);
        setQrCode(null);
        setDebugInfo({ error: null, lastResponse: 'Restarting...' });
        setConnecting((prev) => prev + 1);

        try {
            await fetch(`${apiUrl}/instance/restart/${instanceName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    apikey: apiKey,
                },
            });
        } catch (error) {
            console.error('Connect Error:', error);
            setDebugInfo((prev) => ({ ...prev, error: error.message || 'Connect Failed' }));
        }
        setLoading(false);
    }, [apiKey, apiUrl, instanceName]);

    const handleLogout = useCallback(async () => {
        if (!window.confirm('Deseja realmente desconectar o WhatsApp? Isso apagar√° todos os dados locais.')) return;
        setLoading(true);
        try {
            await WhatsAppService.logoutInstance();
        } catch (error) {
            console.error('Logout backend failed:', error);
        }

        useStore.getState().logout();
        localStorage.clear();
        sessionStorage.clear();
        setTimeout(() => {
            window.location.reload();
        }, 500);
    }, []);

    return {
        qrCode,
        loading,
        status,
        debugInfo,
        socketConnected,
        checkStatus,
        handleConnect,
        handleLogout,
    };
}


--- FILE: src/index.css ---

@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap');

:root {
  --bg-main: #FDFDFD;
  --bg-sidebar: #FFFFFF;
  --bg-chat-list: #FFFFFF;
  --accent-primary: #C5A059;
  --accent-secondary: #af8a43;
  --text-main: #1d1d1f;
  --text-muted: #86868b;
  --glass: rgba(255, 255, 255, 0.85);
  --glass-border: rgba(0, 0, 0, 0.05);
  --danger: #ff4d4d;
  --success: #C5A059;
  --aura-gold: #C5A059;
  --card-bg: #ffffff;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: 'Montserrat', sans-serif;
}

body {
  background: var(--bg-main);
  color: var(--text-main);
  height: 100vh;
  overflow: hidden;
}

#root {
  height: 100%;
}

.app-container {
  display: flex;
  height: 100vh;
  width: 100vw;
  background: var(--bg-main);
  overflow: hidden;
}

/* CRM Mode: Ensure the main content takes over when sidebar is minimal */
.app-container.crm-mode .main-content {
  flex: 1;
  width: 100%;
}

.main-content {
  flex: 1;
  display: flex;
  height: 100vh;
  min-width: 0;
}

/* Light Glassmorphism utility */
.glass-panel {
  background: var(--glass);
  backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.03);
}

.scrollable {
  overflow-y: auto;
  min-height: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--accent-primary) transparent;
}

.scrollable::-webkit-scrollbar {
  width: 4px;
}

.scrollable::-webkit-scrollbar-thumb {
  background: var(--accent-primary);
  border-radius: 10px;
}

button {
  cursor: pointer;
  border: none;
  border-radius: 99px;
  outline: none !important;
  box-shadow: none;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  -webkit-tap-highlight-color: transparent;
}

button:focus,
button:active,
button:focus-visible {
  outline: none !important;
  box-shadow: none !important;
}

input {
  background: #ffffff;
  border: 1px solid var(--glass-border);
  color: var(--text-main);
  padding: 10px 20px;
  border-radius: 99px;
  outline: none;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
}

input:focus {
  border-color: var(--accent-primary);
  box-shadow: 0 0 10px rgba(197, 160, 89, 0.1);
}

/* Sidebar Styles (Restored Dark Premium) */
.sidebar {
  width: 100px;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 30px 0;
  height: 100%;
  border-right: 1px solid var(--glass-border);
  background: #121212;
  /* RESTORED: Dark Background */
  transition: width 0.3s ease;
  z-index: 20;
}

.sidebar:hover {
  width: 120px;
}

.logo-container h1 {
  font-size: 22px;
  font-weight: 800;
  color: #FFFFFF;
  /* CHANGED: White Text */
  text-shadow: 0 0 15px rgba(197, 160, 89, 0.6);
  /* ADDED: Gold Shadow */
  margin-bottom: 50px;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.sidebar ul {
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 25px;
}

.sidebar li {
  color: #FFFFFF;
  /* RESTORED: White text for dark mode */
  opacity: 0.5;
  padding: 12px;
  border-radius: 16px;
  cursor: pointer;
  transition: 0.3s;
}

.sidebar li:hover,
.sidebar li.active {
  color: var(--accent-primary);
  opacity: 1;
  background: rgba(197, 160, 89, 0.15);
}

.sidebar-footer {
  margin-top: auto;
  color: #86868b;
}

/* ChatList Styles (Light) */
.chat-list-container {
  width: 320px;
  flex-shrink: 0;
  border-right: 1px solid var(--glass-border);
  display: flex;
  flex-direction: column;
  background: #ffffff;
  color: var(--text-main);
}

.list-header h2 {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-main);
}

.list-header {
  padding: 30px 25px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.list-header h2 {
  font-size: 20px;
  font-weight: 700;
}

.search-bar {
  margin: 0 25px 20px;
  position: relative;
}

.search-bar svg {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-muted);
}

.search-bar input {
  width: 100%;
  padding-left: 38px;
  font-size: 13px;
}

.chats {
  flex: 1;
  padding: 0 15px;
}

.chat-item {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 12px 15px;
  cursor: pointer;
  transition: all 0.2s;
  border-radius: 12px;
  margin-bottom: 5px;
  min-width: 0;
}

.chat-item:hover {
  background: rgba(0, 0, 0, 0.03);
}

.chat-item.active {
  background: rgba(197, 160, 89, 0.1);
  border-left: 4px solid var(--accent-primary);
}

.avatar {
  width: 50px;
  height: 50px;
  min-width: 50px;
  min-height: 50px;
  border-radius: 50%;
  background: #f0f0f2;
  border: 1px solid rgba(197, 160, 89, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 18px;
  flex-shrink: 0;
  overflow: hidden;
  color: var(--accent-primary);
}

.avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.info {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  text-align: left;
  min-width: 0;
}

.info h4 {
  margin-bottom: 3px;
  font-size: 14px;
  width: 100%;
}

.info p {
  font-size: 12px;
  color: var(--text-muted);
  width: 100%;
}

.spin {
  animation: rotate 1s linear infinite;
}

@keyframes rotate {
  from {
    transform: rotate(0deg)
  }

  to {
    transform: rotate(360deg)
  }
}

.empty-msg {
  text-align: center;
  padding: 20px;
  color: var(--text-muted);
  font-size: 13px;
}

/* ChatArea Styles */
.chat-area {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  flex: 1;
  overflow: hidden;
  height: 100%;
}

.chat-header {
  padding: 20px 30px;
  border-radius: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.active-info h3 {
  font-size: 22px;
}

.active-info p {
  color: var(--accent-primary);
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.actions {
  display: flex;
  align-items: center;
  gap: 10px;
  color: var(--accent-primary);
  font-weight: 700;
}

.main-grid {
  display: flex;
  gap: 15px;
  flex: 1;
  min-height: 0;
  width: 100%;
  padding-bottom: 5px;
}

.messages-column {
  flex: 1;
  min-width: 0;
  border-radius: 20px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.thread {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.message {
  padding: 12px 16px;
  border-radius: 18px;
  max-width: 80%;
  font-size: 14.5px;
  line-height: 1.45;
  position: relative;
  transition: all 0.2s ease;
}

.message.in {
  align-self: flex-start;
  background: #ffffff;
  border: 1px solid rgba(0, 0, 0, 0.05);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
  color: #1c1c1e;
  border-bottom-left-radius: 4px;
}

.message.out {
  align-self: flex-end;
  background: #f2f2f5;
  /* Light gray for premium feel */
  color: #1d1d1f;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(0, 0, 0, 0.03);
  border-bottom-right-radius: 4px;
  font-weight: 400;
}

.analysis-column {
  width: 300px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  flex-shrink: 0;
  overflow-y: auto;
  min-height: 0;
  padding-right: 5px;
}

/* Notebook screens */
@media (max-width: 1366px) {
  .analysis-column {
    width: 260px;
  }
}

.card {
  padding: 24px;
  border-radius: 28px;
  background: #ffffff;
  border: 1px solid rgba(0, 0, 0, 0.04);
  display: flex;
  flex-direction: column;
  gap: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.02);
}

.card h4 {
  font-size: 14px;
  color: var(--accent-primary);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  font-weight: 700;
}

.context-box,
.result-box {
  background: #ffffff;
  border: 1px solid rgba(0, 0, 0, 0.05);
  border-radius: 20px;
  padding: 18px;
  min-height: 120px;
  font-size: 14px;
  color: var(--text-main);
  line-height: 1.6;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.01);
}

.btn-primary {
  background: var(--accent-primary);
  color: #000;
  font-weight: 800;
  padding: 15px;
  font-size: 15px;
  box-shadow: 0 4px 20px rgba(197, 160, 89, 0.2);
  border: none !important;
  outline: none !important;
}

.btn-primary:active,
.btn-primary:focus {
  transform: scale(0.98);
  box-shadow: 0 2px 10px rgba(197, 160, 89, 0.1) !important;
  outline: none !important;
}

.btn-secondary {
  background: transparent;
  border: 1px solid var(--accent-primary);
  color: var(--accent-primary);
  padding: 12px;
  font-weight: 600;
}

.glow-icon {
  filter: drop-shadow(0 0 10px rgba(197, 160, 89, 0.5));
}

.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  width: 500px;
  padding: 40px;
  border-radius: 36px;
  background: #ffffff;
  border: 1px solid rgba(0, 0, 0, 0.05);
  display: flex;
  flex-direction: column;
  gap: 30px;
  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-content form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.input-group label {
  font-size: 13px;
  color: var(--text-muted);
  font-weight: 600;
}

.btn-save {
  background: var(--accent-primary);
  color: #ffffff;
  font-weight: 700;
  padding: 16px;
  border-radius: 99px;
  margin-top: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  box-shadow: 0 8px 20px rgba(197, 160, 89, 0.2);
}

.message-input-area {
  padding: 10px 15px;
  background: transparent;
  display: flex;
  align-items: flex-end;
  gap: 8px;
  width: 100%;
}

.input-container-main {
  flex: 1;
  background: #ffffff;
  border-radius: 24px;
  display: flex;
  align-items: center;
  padding: 5px 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  min-height: 48px;
}

.message-input-area input {
  flex: 1;
  background: transparent !important;
  border: none !important;
  padding: 10px 12px !important;
  font-size: 16px !important;
  outline: none !important;
  box-shadow: none !important;
}

/* Suggested Response Card - Mobile */
.mobile-suggestion-card {
  margin: 0 15px 8px;
  padding: 15px;
  border-radius: 20px;
  background: #ffffff;
  border: 1px solid rgba(197, 160, 89, 0.15);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
  animation: slideInUp 0.3s ease;
}

.suggestion-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  font-size: 12px;
  font-weight: 600;
  color: var(--accent-primary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.suggestion-text {
  font-size: 14px;
  line-height: 1.4;
  color: #48484a;
  margin-bottom: 12px;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.use-suggestion-btn {
  width: 100%;
  padding: 10px;
  background: rgba(197, 160, 89, 0.1);
  color: var(--accent-primary);
  border: none;
  border-radius: 12px;
  font-weight: 700;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.use-suggestion-btn:active {
  background: rgba(197, 160, 89, 0.2);
  transform: scale(0.98);
}

.close-suggestion {
  background: none;
  border: none;
  color: #8e8e93;
  cursor: pointer;
  padding: 4px;
}

@keyframes slideInUp {
  from {
    transform: translateY(10px);
    opacity: 0;
  }

  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Utility for empty states */
.empty-dashboard {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  flex: 1;
  opacity: 0.8;
}

.empty-dashboard h2 {
  margin-top: 20px;
}

.force-search {
  padding: 20px;
  text-align: center;
}

.force-search p {
  font-size: 13px;
  color: var(--text-muted);
  margin-bottom: 10px;
}

.message-input-area {
  margin-top: 15px;
  display: flex;
  gap: 10px;
  background: #f0f0f2;
  padding: 8px 12px;
  border-radius: 99px;
  border: 1px solid rgba(0, 0, 0, 0.05);
}

.message-input-area input {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-main);
  padding: 5px 10px;
  font-size: 14px;
}

.message-input-area input:focus {
  outline: none;
}

.message-input-area button {
  background: var(--accent-primary);
  border: none;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #000;
  cursor: pointer;
  transition: 0.23s cubic-bezier(0.4, 0, 0.2, 1);
}

.message-input-area button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.message-input-area button:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 0 15px var(--accent-primary);
}

.loading-txt {
  text-align: center;
  font-size: 12px;
  opacity: 0.5;
  margin-top: 10px;
}

.btn-force {
  background: var(--accent-primary);
  color: var(--bg-main);
  border: none;
  padding: 10px;
  border-radius: 8px;
  font-weight: 700;
  cursor: pointer;
  font-size: 12px;
  width: 100%;
}

.badge-v3 {
  background: linear-gradient(135deg, #C5A059, #8c6a2d);
  color: #fff;
  font-size: 10px;
  font-weight: 900;
  padding: 4px 14px;
  border-radius: 99px;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  box-shadow: 0 4px 10px rgba(197, 160, 89, 0.3);
}

.card-header-v3 {
  display: flex;
  align-items: center;
  gap: 10px;
  color: var(--accent-primary);
  margin-bottom: 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  padding-bottom: 10px;
}

.card-header-v3 h4 {
  margin: 0;
  font-size: 13px !important;
}

.v3-data-grid {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 15px;
}

.data-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
}

.data-item label {
  font-size: 9px;
  color: var(--text-muted);
  text-transform: uppercase;
  font-weight: 700;
  letter-spacing: 0.5px;
}

.data-item span {
  font-size: 12px;
  color: var(--text-main);
  /* Changed from white to dark */
  font-weight: 600;
  text-align: right;
}

/* Message Date Separators */
.date-separator {
  display: flex;
  justify-content: center;
  margin: 16px 0;
  opacity: 0.8;
}

.date-separator span {
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-secondary);
  font-size: 11px;
  padding: 4px 12px;
  border-radius: 12px;
  backdrop-filter: blur(4px);
  border: 1px solid rgba(255, 255, 255, 0.05);
}

/* Timestamp inside message */
.msg-time {
  display: block;
  font-size: 10px;
  text-align: right;
  margin-top: 4px;
  opacity: 0.6;
  line-height: 1;
}

.message.out .msg-time {
  color: inherit;
  font-weight: 500;
}

.message.in .msg-time {
  color: var(--text-muted);
}

/* Adjust message padding to accommodate time */
.message {
  padding-bottom: 6px;
  position: relative;
  min-width: 80px;
}

.v3-btn {
  width: 100%;
  padding: 12px !important;
  font-size: 13px !important;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.v3-btn-sub {
  width: 100%;
  margin-top: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.v3-box {
  min-height: 100px !important;
  line-height: 1.5 !important;
}

.v3-analysis {
  background: rgba(197, 160, 89, 0.03) !important;
  border: 1px solid rgba(197, 160, 89, 0.1) !important;
}

.v3-suggestion {
  background: #f9f9fb !important;
  border: 1px solid rgba(0, 0, 0, 0.03) !important;
}

.btn-enhance {
  background: rgba(197, 160, 89, 0.08);
  border: none;
  color: var(--accent-primary);
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: 0.2s;
  border-radius: 50%;
}

.btn-enhance:hover {
  background: rgba(197, 160, 89, 0.15);
}

.btn-enhance.active {
  background: var(--accent-primary);
  color: #000;
}

.chat-main-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.chat-preview {
  font-size: 12px !important;
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-top: 2px;
  color: var(--text-muted);
}

.chat-time {
  font-size: 10px;
  opacity: 0.5;
}

.qr-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px;
  background: white;
  border-radius: 20px;
  margin: 10px 0;
}

.qr-code {
  width: 250px;
  height: 250px;
}

.status-badge {
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
}

.status-badge.connected {
  background: rgba(0, 210, 193, 0.2);
  color: var(--accent-primary);
  border: 1px solid var(--accent-primary);
}

.status-badge.disconnected {
  background: rgba(255, 77, 77, 0.2);
  color: var(--danger);
  border: 1px solid var(--danger);
}

.btn-danger {
  background: rgba(255, 77, 77, 0.1);
  color: var(--danger);
  border: 1px solid var(--danger);
  padding: 10px;
  font-weight: 700;
  width: 100%;
}

.btn-danger:hover {
  background: var(--danger);
  color: white;
}

.btn-danger:hover {
  background: var(--danger);
  color: white;
}

/* CRM Kanban Styles - BRIGHT PREMIUM */
.crm-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding: 30px;
  background: var(--bg-main);
  overflow: hidden;
}

.crm-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
  padding: 0;
  background: transparent;
}

.stat-value {
  font-size: 24px;
  font-weight: 800;
  color: #1d1d1f;
}

.crm-board {
  display: flex;
  gap: 24px;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 10px 0 20px;
  flex: 1;
  align-items: flex-start;
}

.crm-column {
  min-width: 300px;
  flex: 0 0 300px;
  background: rgba(0, 0, 0, 0.02);
  border-radius: 24px;
  display: flex;
  flex-direction: column;
  height: 100%;
  border: 1px solid rgba(0, 0, 0, 0.03);
}

.column-header {
  padding: 20px 25px;
  font-weight: 800;
  font-size: 14px;
  color: #1d1d1f;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.crm-card {
  background: #ffffff;
  border-radius: 18px;
  padding: 20px;
  margin-bottom: 15px;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.03);
  border: 1px solid rgba(0, 0, 0, 0.05);
}

.crm-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 12px 25px rgba(197, 160, 89, 0.1);
  border-color: var(--accent-primary);
}

.crm-card h4 {
  color: #1d1d1f;
  font-size: 15px;
  font-weight: 700;
  margin: 0 0 10px 0;
}

.crm-card p {
  color: #86868b;
  font-size: 13px;
  margin: 0;
  line-height: 1.5;
}

.crm-card .next-steps {
  background: #FDFCF8;
  border-left: 3px solid var(--accent-primary);
  padding: 15px;
  border-radius: 12px;
  margin: 15px 0;
}

.crm-card .next-steps h5 {
  color: var(--accent-primary);
  font-size: 11px;
  font-weight: 800;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.crm-card .next-steps ul {
  padding-left: 20px;
  color: #4a4a4c;
  font-size: 13px;
}

/* =========================================
   MOBILE RESPONSIVENESS (BREAKPOINT: 768px)
   ========================================= */
@media (max-width: 768px) {

  /* ROOT OVERRIDES FOR MOBILE */
  body {
    height: 100%;
    min-height: -webkit-fill-available;
    /* Fixed height on iOS/Chrome */
    position: fixed;
    /* Prevent rubber-banding on whole page */
    width: 100%;
  }

  .app-container {
    position: relative;
    width: 100%;
    height: 100dvh;
    padding-top: env(safe-area-inset-top);
    /* Safe Area for Notch */
    padding-bottom: 0;
    /* REMOVED TO PREVENT DOUBLE PADDING */
    overflow: hidden;
    display: block;
    /* Overwrite flex */
  }

  /* 1. Sidebar (Default: Hidden/Overlay) */
  .sidebar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 85%;
    max-width: 300px;
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 10px 0 30px rgba(0, 0, 0, 0.4);
    background: #090909;
    /* Deep Premium Black */
    border-right: 1px solid rgba(255, 255, 255, 0.05);
  }

  .sidebar.mobile-open {
    transform: translateX(0);
  }

  .sidebar-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(8px);
    /* Premium Blur */
    z-index: 999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .sidebar-overlay.open {
    opacity: 1;
    pointer-events: auto;
  }

  .mobile-close-btn {
    display: flex !important;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(15px + env(safe-area-inset-top));
    right: 15px;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: #fff;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    z-index: 1010;
  }

  /* 2. Main Content & ChatList Transition Logic */
  /* We use a 'sliding context' where the list stays left and chat comes over it */

  .chat-list-container {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
    background: var(--bg-main);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .main-content {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 20;
    transform: translateX(100%);
    /* Start hidden to the right */
    transition: transform 0.35s cubic-bezier(0.16, 1, 0.3, 1);
    /* Faster, snappy out, slow in */
    background: var(--bg-main);
    display: flex;
    flex-direction: column;
    box-shadow: -5px 0 25px rgba(0, 0, 0, 0.05);
  }

  /* VIEW STATE: Chat Open */
  .main-content.mobile-chat-open {
    transform: translateX(0);
  }

  /* When Chat is open, slightly move back the list to give depth (iOS style) */
  .app-container:has(.mobile-chat-open) .chat-list-container {
    transform: translateX(-15%);
    opacity: 0.8;
  }

  /* 3. Specialized Mobile Headers */
  .list-header,
  .chat-header {
    height: 65px;
    padding-top: env(safe-area-inset-top);
    display: flex;
    align-items: center;
    background: rgba(255, 255, 255, 0.92) !important;
    backdrop-filter: blur(25px) !important;
    z-index: 50;
    border-bottom: 1px solid rgba(0, 0, 0, 0.04) !important;
  }

  .chat-header {
    padding-left: 10px !important;
  }

  /* 4. Chat Item Enhancements */
  .chat-item {
    padding: 16px 20px !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.02) !important;
  }

  .chat-item .avatar {
    width: 50px !important;
    height: 50px !important;
    font-size: 18px !important;
  }

  /* 5. Message Aesthetics */
  .messages-column {
    padding: 15px !important;
  }

  .message-wrapper {
    margin-bottom: 10px !important;
  }

  .message-content {
    max-width: 88% !important;
    font-size: 14.5px !important;
    padding: 10px 14px !important;
    border-radius: 18px !important;
    line-height: 1.4 !important;
  }

  .message-wrapper.sent .message-content {
    border-bottom-right-radius: 4px !important;
  }

  .message-wrapper.received .message-content {
    border-bottom-left-radius: 4px !important;
  }

  /* 6. Input Area (Native Floating Style) */
  .message-input-area {
    padding: 10px 15px calc(10px + env(safe-area-inset-bottom)) 15px !important;
    background: var(--bg-main);
    border-top: none !important;
  }

  .message-input-area form {
    background: #f2f2f7;
    padding: 4px 6px 4px 15px !important;
    border-radius: 25px !important;
    border: 1px solid rgba(0, 0, 0, 0.05) !important;
    box-shadow: none !important;
  }

  .message-input-area input {
    font-size: 16px !important;
    /* iOS no-zoom */
    background: transparent !important;
    border: none !important;
    padding: 10px 0 !important;
  }

  .message-input-area .icon-btn {
    background: var(--accent-primary) !important;
    color: #000 !important;
    width: 34px !important;
    height: 34px !important;
    border-radius: 50% !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center;
    justify-content: center;
  }

  /* 7. Hide Analysis/Desktop Panes */
  .main-grid {
    grid-template-columns: 1fr;
    height: 100%;
  }

  .analysis-column {
    display: none;
    /* Default hidden, but we'll add a way to see it */
  }

  .mobile-menu-btn,
  .mobile-back-btn,
  .mobile-analysis-btn {
    display: flex !important;
    width: 40px;
    height: 40px;
    align-items: center;
    justify-content: center;
    color: var(--accent-primary) !important;
  }

  /* Placeholder logic */
  .history-placeholder {
    display: none !important;
    /* Never show placeholders on mobile, show list instead */
  }
}

/* Ensure Desktop still hides mobile stuff */
.mobile-close-btn,
.mobile-menu-btn,
.mobile-back-btn,
.sidebar-overlay {
  display: none;
}

/* ========================================= */
/* BETA - New Features (Timestamps & Grouping) */
/* ========================================= */

/* Message Date Separators */
.date-separator {
  display: flex;
  justify-content: center;
  margin: 16px 0;
  opacity: 0.8;
}

.date-separator span {
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-secondary);
  font-size: 11px;
  padding: 4px 12px;
  border-radius: 12px;
  backdrop-filter: blur(4px);
  border: 1px solid rgba(255, 255, 255, 0.05);
}

/* Timestamp inside message */
.msg-time {
  display: block;
  font-size: 10px;
  text-align: right;
  margin-top: 4px;
  opacity: 0.6;
  line-height: 1;
}

.message.out .msg-time {
  color: inherit;
  font-weight: 500;
}

.message.in .msg-time {
  color: var(--text-muted);
}

/* Adjust message padding to accommodate time */
.message {
  padding-bottom: 6px;
  position: relative;
  min-width: 80px;
}

--- FILE: src/landing.jsx ---

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
// import './index.css' // REMOVED: Index.css is for the System App, not Landing Page
import LandingPage from './pages/LandingPage.jsx'

// Simple redirector: saves lead to storage and goes to /app
const handleGetStarted = () => {
    window.location.href = '/app/';
};

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <LandingPage onGetStarted={handleGetStarted} />
    </StrictMode>,
)


--- FILE: src/main.jsx ---

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

import { useStore } from './store/useStore';

window.useStore = useStore;

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--- FILE: src/pages/LandingPage.css ---

/* ========================================
   AURA CORPORATE PREMIUM (v3.0)
   Theme: Clean, Professional, White/Gray/Gold
   ======================================== */

@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap');

:root {
    /* PREMIUM PALETTE */
    --bg-white: #FFFFFF;
    --bg-light: #F5F5F7;
    /* Apple Light Gray */
    --bg-medium: #E5E5E5;

    --text-primary: #1D1D1F;
    /* Apple Dark */
    --text-secondary: #86868B;

    --gold-primary: #C5A059;
    --gold-dark: #A08040;
    --gold-light: #E5C580;

    --shadow-sm: 0 4px 12px rgba(0, 0, 0, 0.05);
    --shadow-md: 0 12px 32px rgba(0, 0, 0, 0.08);
    --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.12);
}

html,
body {
    margin: 0;
    padding: 0;
    background-color: var(--bg-white) !important;
    color: var(--text-primary) !important;
    overflow-x: hidden;
    overflow-y: auto !important;
    font-family: 'Outfit', sans-serif;
    -webkit-font-smoothing: antialiased;
}

.landing-page {
    width: 100%;
    position: relative;
    background: var(--bg-white);
}

/* ========================================
   TOP BAR
   ======================================== */
.landing-top-bar {
    position: fixed;
    top: 0;
    width: 100%;
    z-index: 1000;
    padding: 16px 40px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.top-bar-logo {
    opacity: 1;
}

.btn-login {
    background: transparent;
    border: 1px solid var(--text-primary);
    color: var(--text-primary);
    padding: 8px 20px;
    border-radius: 50px;
    cursor: pointer;
    font-weight: 500;
    font-size: 14px;
    transition: all 0.2s;
}

.btn-login:hover {
    background: var(--text-primary);
    color: #fff;
}

/* ========================================
   HERO SECTION
   ======================================== */
.hero {
    min-height: 90vh;
    padding: 140px 20px 80px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    background: radial-gradient(circle at 50% 0%, #FAFAFA 0%, #FFFFFF 100%);
}

.hero-content {
    max-width: 800px;
    margin-bottom: 60px;
}

.badge-new {
    display: inline-block;
    background: var(--bg-light);
    color: var(--gold-primary);
    font-weight: 700;
    font-size: 12px;
    padding: 6px 16px;
    border-radius: 20px;
    letter-spacing: 1px;
    margin-bottom: 24px;
    border: 1px solid rgba(197, 160, 89, 0.2);
}

.hero-title {
    font-size: 64px;
    line-height: 1.1;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 24px;
    letter-spacing: -1.5px;
}

.hero-title .highlight {
    color: var(--gold-primary);
}

.hero-subtitle {
    font-size: 20px;
    line-height: 1.5;
    color: var(--text-secondary);
    margin-bottom: 40px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}

.cta-group {
    display: flex;
    gap: 16px;
    justify-content: center;
}

.cta-button {
    padding: 16px 32px;
    border-radius: 50px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    border: none;
}

.cta-button.primary {
    background: var(--text-primary);
    color: #fff;
    box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
}

.cta-button.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}

.cta-button.secondary {
    background: #fff;
    color: var(--text-primary);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.cta-button.secondary:hover {
    background: var(--bg-light);
}

/* ========================================
   DEMO / MOCKUP SECTION
   ======================================== */
.demo-container {
    width: 100%;
    max-width: 900px;
    background: #fff;
    border-radius: 24px;
    box-shadow: var(--shadow-lg);
    border: 1px solid rgba(0, 0, 0, 0.05);
    padding: 40px;
    display: flex;
    gap: 40px;
    margin-top: 20px;
    position: relative;
    overflow: hidden;
}

.demo-chat {
    flex: 2;
    background: #F2F2F7;
    /* WhatsApp-like bg */
    border-radius: 16px;
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.msg {
    padding: 12px 18px;
    border-radius: 12px;
    font-size: 15px;
    line-height: 1.4;
    max-width: 85%;
    position: relative;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.msg.user {
    align-self: flex-start;
    background: #fff;
    color: #000;
    border-top-left-radius: 2px;
}

.msg.aura {
    align-self: flex-end;
    background: #DCF8C6;
    /* Greenish App tint */
    background: var(--text-primary);
    /* Keeping it elegant brand color */
    color: #fff;
    border-top-right-radius: 2px;
}

.analysis-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    gap: 24px;
    border-left: 1px solid var(--bg-medium);
    padding-left: 40px;
}

.analysis-item label {
    font-size: 11px;
    font-weight: 700;
    color: var(--text-secondary);
    letter-spacing: 1px;
    text-transform: uppercase;
    display: block;
    margin-bottom: 6px;
}

.analysis-item div {
    font-family: 'Outfit', sans-serif;
    font-size: 16px;
    font-weight: 600;
    color: var(--gold-primary);
}

/* ========================================
   FEATURES SECTION
   ======================================== */
.features {
    padding: 100px 20px;
    background: var(--bg-light);
}

.section-title {
    text-align: center;
    font-size: 40px;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 60px;
    letter-spacing: -1px;
}

.features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 32px;
    max-width: 1200px;
    margin: 0 auto;
}

.feature-card {
    background: #fff;
    padding: 40px 32px;
    border-radius: 20px;
    box-shadow: var(--shadow-sm);
    text-align: left;
    transition: all 0.3s ease;
    border: 1px solid rgba(0, 0, 0, 0.03);
}

.feature-card:hover {
    transform: translateY(-5px);
    box-shadow: var(--shadow-md);
}

.feature-icon {
    color: var(--gold-primary);
    margin-bottom: 24px;
}

.feature-card h4 {
    font-size: 20px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 12px;
}

.feature-card p {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-secondary);
}

/* ========================================
   PRICING SECTION
   ======================================== */
.pricing {
    padding: 100px 20px;
    background: #fff;
}

.pricing-grid {
    max-width: 1100px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
    gap: 40px;
    justify-content: center;
}

.pricing-card {
    background: #fff;
    padding: 48px 32px;
    border-radius: 24px;
    border: 1px solid var(--bg-medium);
    text-align: left;
    position: relative;
    transition: all 0.3s ease;
}

.pricing-card:hover {
    border-color: var(--text-primary);
    box-shadow: var(--shadow-md);
}

.pricing-card.recommended {
    border: 2px solid var(--gold-primary);
    background: #FFFCF5;
    /* Very subtle gold tint */
}

.badge {
    position: absolute;
    top: -14px;
    left: 32px;
    background: var(--gold-primary);
    color: #fff;
    font-size: 12px;
    font-weight: 700;
    padding: 6px 16px;
    border-radius: 20px;
    text-transform: uppercase;
}

.pricing-card h4 {
    font-size: 24px;
    font-weight: 700;
    color: var(--text-primary);
    margin-bottom: 16px;
}

.price-value {
    font-size: 48px;
    font-weight: 800;
    color: var(--text-primary);
    letter-spacing: -1px;
}

.price-period {
    color: var(--text-secondary);
    font-size: 18px;
}

.features-list {
    margin: 32px 0;
    list-style: none;
}

.features-list li {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    color: var(--text-primary);
    font-size: 15px;
}

.features-list li svg {
    color: var(--gold-primary);
    flex-shrink: 0;
}

.btn-gold,
.btn-outline {
    width: 100%;
    padding: 18px;
    border-radius: 12px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
}

.btn-gold {
    background: var(--gold-primary);
    color: #fff;
    border: none;
}

.btn-gold:hover {
    background: var(--gold-dark);
}

.btn-outline {
    background: transparent;
    border: 1px solid var(--bg-medium);
    color: var(--text-primary);
}

.btn-outline:hover {
    border-color: var(--text-primary);
}

/* ========================================
   REGISTRATION SECTION
   ======================================== */
.registration {
    padding: 100px 20px;
    background: var(--bg-light);
}

.registration-container {
    max-width: 500px;
    margin: 0 auto;
    text-align: center;
}

.registration-form {
    background: #fff;
    padding: 40px;
    border-radius: 24px;
    box-shadow: var(--shadow-sm);
    text-align: left;
}

.form-group label {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 8px;
    display: block;
}

.form-group input,
.form-group select {
    width: 100%;
    padding: 14px;
    border: 1px solid var(--bg-medium);
    border-radius: 12px;
    font-size: 15px;
    transition: all 0.2s;
    background: var(--bg-light);
}

.form-group input:focus,
.form-group select:focus {
    outline: none;
    border-color: var(--gold-primary);
    background: #fff;
}

.btn-submit {
    width: 100%;
    padding: 16px;
    background: var(--text-primary);
    color: #fff;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 24px;
    display: flex;
    justify-content: center;
    gap: 8px;
}

.btn-submit:hover {
    background: #000;
}

/* ========================================
   FOOTER
   ======================================== */
.footer {
    background: #111;
    color: #888;
    padding: 60px 20px;
}

.footer-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.footer-links {
    display: flex;
    gap: 32px;
}

.footer-links a {
    color: #888;
    text-decoration: none;
    font-size: 14px;
    transition: color 0.2s;
}

.footer-links a:hover {
    color: #fff;
}

/* ========================================
   RESPONSIVE
   ======================================== */
@media (max-width: 768px) {
    .hero-title {
        font-size: 40px;
    }

    .demo-container {
        flex-direction: column;
        padding: 24px;
    }

    .analysis-panel {
        border-left: none;
        border-top: 1px solid var(--bg-medium);
        padding-left: 0;
        padding-top: 24px;
        flex-direction: row;
        justify-content: space-between;
    }

    .cta-group {
        flex-direction: column;
    }

    .pricing-card.recommended {
        transform: scale(1);
    }
}

--- FILE: src/pages/LandingPage.jsx ---

import React, { useState } from 'react';
import { Check, Zap, Brain, TrendingUp, Users, Shield, ArrowRight } from 'lucide-react';
import logoLight from '../assets/logo-light.png';
import logoDark from '../assets/logo-dark.png';
// Decoupled: No more useStore import
import './LandingPage.css';

const LandingPage = ({ onGetStarted }) => {
    // FAILSAFE: If this loads on /app/, redirect to login.html
    useEffect(() => {
        if (window.location.pathname.startsWith('/app')) {
            console.warn('AURA: Landing loaded on /app route. Redirecting to login.html...');
            window.location.href = '/login.html';
        }
    }, []);

    const [formData, setFormData] = useState({
        name: '',
        email: '',
        company: '',
        plan: 'pro'
    });



    const features = [
        {
            icon: <Brain size={32} />,
            title: 'Co-Piloto Inteligente',
            description: 'A IA analisa a conversa e sugere a resposta perfeita. Voc√™ edita e envia.'
        },
        {
            icon: <TrendingUp size={32} />,
            title: 'Pipeline de Vendas',
            description: 'Organize pacientes por etapa: Agendamento, Avalia√ß√£o e Fechamento.'
        },
        {
            icon: <Users size={32} />,
            title: 'Hist√≥rico e Contexto',
            description: 'A IA lembra de tudo o que foi conversado para n√£o perder detalhes.'
        },
        {
            icon: <Zap size={32} />,
            title: 'Agilidade no Atendimento',
            description: 'Sua secret√°ria responde 10x mais r√°pido com sugest√µes prontas.'
        },
        {
            icon: <Shield size={32} />,
            title: 'Controle Total',
            description: 'Nada √© enviado sem sua aprova√ß√£o. A tecnologia serve voc√™.'
        }
    ];

    const plans = [
        {
            id: 'starter',
            name: 'Starter',
            price: 'R$ 197',
            period: '/m√™s',
            features: [
                '1 n√∫mero WhatsApp',
                'IA GPT-4o (Igual ao Pro)',
                'CRM Completo',
                'Limitado a 500 msgs/m√™s',
                'Suporte por email'
            ],
            recommended: false,
            link: 'https://pay.hotmart.com/placeholder-starter'
        },
        {
            id: 'pro',
            name: 'Pro',
            price: 'R$ 397',
            period: '/m√™s',
            features: [
                '3 n√∫meros WhatsApp',
                'IA GPT-4o (Igual ao Starter)',
                'CRM Completo',
                'Mensagens e Leads ILIMITADOS',
                'Suporte Priorit√°rio'
            ],
            recommended: true,
            link: 'https://pay.hotmart.com/placeholder-pro'
        }
    ];

    const handlePlanSelect = (plan) => {
        if (plan.action === 'contact') {
            window.open('https://wa.me/5511999999999?text=Interesse no Plano Enterprise', '_blank');
        } else {
            setFormData({ ...formData, plan: plan.id });
            document.getElementById('register')?.scrollIntoView({ behavior: 'smooth' });
        }
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('Form submitted:', formData);

        // DECOUPLED INTEGRATION
        // 1. Save Lead to LocalStorage (App will pick this up on load)
        localStorage.setItem('aura_pending_lead', JSON.stringify(formData));

        // 2. Auto-Login (Demo Mode)
        const token = btoa(`authenticated:${Date.now()}`);
        localStorage.setItem('auth_token', token);

        // 3. Trigger transition to App
        onGetStarted();
    };

    return (
        <div className="landing-page">
            {/* Top Bar */}
            <div className="landing-top-bar">
                <div className="top-bar-logo">
                    <img src={logoLight} alt="AURA" style={{ height: '24px' }} />
                </div>
                <button className="btn-login" onClick={onGetStarted}>
                    J√° sou Cliente
                </button>
            </div>

            {/* Hero Section */}
            <section className="hero">
                <div className="hero-content">
                    <span className="badge-new">NOVA VERS√ÉO 12.0</span>

                    <h1 className="hero-title">
                        A Intelig√™ncia que<br />
                        <span className="highlight">Potencializa sua Cl√≠nica</span>
                    </h1>

                    <p className="hero-subtitle">
                        Transforme o WhatsApp em uma m√°quina de agendamentos.
                        O <strong>AURA</strong> √© o co-piloto que sugere respostas perfeitas para sua secret√°ria fechar mais tratamentos.
                    </p>

                    <div className="cta-group">
                        <button className="cta-button primary" onClick={() => document.getElementById('register')?.scrollIntoView({ behavior: 'smooth' })}>
                            Come√ßar Agora <ArrowRight size={20} />
                        </button>
                        <button className="cta-button secondary" onClick={() => window.open('https://wa.me/5511999999999', '_blank')}>
                            Ver Demonstra√ß√£o
                        </button>
                    </div>
                </div>

                {/* INTERACTIVE DEMO ("The Machine") */}
                <div className="demo-container">
                    <div className="demo-chat">
                        <div className="msg user" style={{ animationDelay: '0.5s' }}>Boa tarde, gostaria de saber o valor do Invisalign.</div>
                        <div className="msg aura" style={{ animationDelay: '2.5s' }}>
                            Oi! O Invisalign varia conforme a complexidade, mas √© o investimento certo para quem busca est√©tica e conforto. üíé Quer agendar uma avalia√ß√£o para simularmos seu sorriso?
                        </div>
                    </div>
                    <div className="analysis-panel">
                        <div className="analysis-item">
                            <label>INTEN√á√ÉO DETECTADA</label>
                            <div>FINANCEIRO (ALTA)</div>
                        </div>
                        <div className="analysis-item">
                            <label>ESTRAT√âGIA</label>
                            <div>Valoriza√ß√£o + Agendamento</div>
                        </div>
                        <div className="analysis-item">
                            <label>PROBABILIDADE VENDA</label>
                            <div style={{ color: '#00ff88' }}>87.5%</div>
                        </div>
                    </div>
                </div>
            </section>

            {/* Features Section */}
            <section className="features">
                <h3 className="section-title">Por que AURA?</h3>
                <div className="features-grid">
                    {features.map((feature, idx) => (
                        <div key={idx} className="feature-card">
                            <div className="feature-icon">{feature.icon}</div>
                            <h4>{feature.title}</h4>
                            <p>{feature.description}</p>
                        </div>
                    ))}
                </div>
            </section>

            {/* Pricing Section */}
            <section className="pricing">
                <h3 className="section-title">Escolha seu Plano</h3>
                <div className="pricing-grid">
                    {plans.map((plan, idx) => (
                        <div key={idx} className={`pricing-card ${plan.recommended ? 'recommended' : ''}`}>
                            {plan.recommended && <div className="badge">Mais Popular</div>}
                            <h4>{plan.name}</h4>
                            <div className="price">
                                <span className="price-value">{plan.price}</span>
                                <span className="price-period">{plan.period}</span>
                            </div>
                            <ul className="features-list">
                                {plan.features.map((f, i) => (
                                    <li key={i}><Check size={18} /> {f}</li>
                                ))}
                            </ul>
                            <button
                                className={plan.recommended ? 'btn-gold' : 'btn-outline'}
                                onClick={() => handlePlanSelect(plan)}
                            >
                                {plan.action === 'contact' ? 'Falar com Consultor' : `Assinar ${plan.name}`}
                            </button>
                        </div>
                    ))}
                </div>
            </section>

            {/* Registration Form */}
            <section id="register" className="registration">
                <div className="registration-container">
                    <h3 className="section-title">Comece Agora Gratuitamente</h3>
                    <p className="registration-subtitle">7 dias de teste gr√°tis. Cancele quando quiser.</p>

                    <form onSubmit={handleSubmit} className="registration-form">
                        <div className="form-group">
                            <label>Nome Completo</label>
                            <input
                                type="text"
                                placeholder="Seu nome"
                                value={formData.name}
                                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                                required
                            />
                        </div>

                        <div className="form-group">
                            <label>Email</label>
                            <input
                                type="email"
                                placeholder="seu@email.com"
                                value={formData.email}
                                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                                required
                            />
                        </div>

                        <div className="form-group">
                            <label>Empresa</label>
                            <input
                                type="text"
                                placeholder="Nome da sua empresa"
                                value={formData.company}
                                onChange={(e) => setFormData({ ...formData, company: e.target.value })}
                                required
                            />
                        </div>

                        <div className="form-group">
                            <label>Plano Desejado</label>
                            <select
                                value={formData.plan}
                                onChange={(e) => setFormData({ ...formData, plan: e.target.value })}
                            >
                                <option value="starter">Starter - R$ 197/m√™s</option>
                                <option value="pro">Pro - R$ 497/m√™s</option>
                                <option value="enterprise">Enterprise - Personalizado</option>
                            </select>
                        </div>

                        <button type="submit" className="btn-submit">
                            Iniciar Teste Gratuito <ArrowRight size={20} />
                        </button>

                        <p className="form-note">
                            Ao cadastrar, voc√™ concorda com nossos Termos de Uso
                        </p>
                    </form>
                </div>
            </section>

            {/* Footer */}
            <footer className="footer">
                <div className="footer-content">
                    <div className="footer-logo">
                        <img src={logoLight} alt="AURA" style={{ height: '32px', marginBottom: '10px' }} />
                    </div>
                    <div className="footer-links">
                        <a href="#features">Recursos</a>
                        <a href="#pricing">Pre√ßos</a>
                        <a href="#contact">Contato</a>
                        <a href="#privacy">Privacidade</a>
                    </div>
                </div>
                <div className="footer-bottom">
                    <p>¬© 2026 AURA. Todos os direitos reservados.</p>
                </div>
            </footer>
        </div>
    );
};

export default LandingPage;


--- FILE: src/services/openai.js ---

const MASTER_AI_KEY = import.meta.env.VITE_OPENAI_API_KEY;

class OpenAIService {
    async generateSuggestion({ clientName, history, briefing, extraContext = "" }) {
        const openaiKey = MASTER_AI_KEY;
        const systemPrompt = `
Voc√™ √© o Especialista de Vendas AURA v10 da VoxeFlow.
Sua miss√£o: CONECTAR e CONVERTER.

DIRETRIZES DE OURO (Siga ou falhe):
1. ü§´ BREVIDADE EXTREMA: M√°ximo de 3 frases. Seja direto.
2. ü™ù GANCHO OBRIGAT√ìRIO: TODA mensagem deve terminar com uma PERGUNTA.
3. ü§ù HUMANIDADE: Use tom natural de WhatsApp, emojis moderados. Nada de "text√£o" corporativo.
4. üß† C√âREBRO TRAVADO: Use APENAS a Base de Conhecimento abaixo.

BASE DE CONHECIMENTO (Sua √önica Verdade):
${briefing}

${extraContext ? `DADOS T√âCNICOS (RAG): ${extraContext}` : ''}
`.trim();

        // 1. Prepare Messages
        const messages = [{ role: 'system', content: systemPrompt }];
        if (Array.isArray(history)) messages.push(...history);
        messages.push({
            role: 'user',
            content: `Responda ${clientName}.
            
            üö® REGRAS CR√çTICAS:
            1. Curto (Max 3 linhas).
            2. Termine com Pergunta.
            3. Se n√£o souber: [KNOWLEDGE_GAP: Pergunta curta para o dono]`
        });

        const payload = {
            model: 'gpt-4o',
            messages: messages,
            temperature: 0.5,
            max_tokens: 350
        };

        // HYBRID STRATEGY: Try Proxy first, then Direct Fallback
        try {
            const response = await fetch('/api/ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                const data = await response.json();
                if (!data.error) {
                    let result = data.choices[0].message.content.trim();
                    return result.replace(/^(Empresa|Aura|Vendedor|Assistant|Atendente):\s*/i, '');
                }
            }
            throw new Error(`Proxy failed: ${response.status}`);
        } catch (proxyError) {
            console.warn("AURA: Proxy failed, attempting direct client-side fallback...", proxyError);
            if (openaiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (!data.error) {
                        return data.choices[0].message.content.trim();
                    }
                } catch (directError) {
                    console.error("AURA: Direct fallback also failed.", directError);
                }
            }
            return null;
        }
    }

    async enhanceMessage(text, context = {}) {
        const openaiKey = MASTER_AI_KEY;
        const systemPrompt = `
            Voc√™ √© o Consultor de Vendas S√™nior da AURA. Refine a mensagem para ser mais humana, persuasiva e aplicar SPIN Selling.
            CONTEXTO: ${context.briefing || 'Empresa de Alto Padr√£o'}
            RETORNE APENAS O TEXTO FINAL.
            `.trim();

        const payload = {
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: text }
            ],
            temperature: 0.7,
            max_tokens: 300
        };

        try {
            const response = await fetch('/api/ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) {
                const data = await response.json();
                return data.choices[0].message.content.trim();
            }
            throw new Error(`Proxy failed: ${response.status}`);
        } catch (e) {
            if (openaiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    return data.choices[0].message.content.trim();
                } catch (dE) { return text; }
            }
            return text;
        }
    }

    async analyzeNextSteps(chatHistory, patientName, currentTag) {
        const openaiKey = MASTER_AI_KEY;
        // Skip check here to try proxy first

        const systemPrompt = `
            Voc√™ √© consultor de vendas EXPERT. Analise a conversa e gere um relat√≥rio CRM.
            HIST√ìRICO: ${chatHistory}
            RETORNE JSON: { 
                "temperature": "quente|morno|frio", 
                "summary": "Resumo de 1 frase", 
                "steps": ["Passo 1", "Passo 2"], 
                "priority": "high|medium|low" 
            }
            `.trim();

        const payload = {
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: 'Analise e sugira os pr√≥ximos passos.' }
            ],
            temperature: 0.7,
            max_tokens: 300,
            response_format: { type: "json_object" }
        };

        const fallbackError = {
            steps: ['Revisar conversa manualmente'],
            priority: 'medium',
            reasoning: 'Erro na an√°lise autom√°tica'
        };

        try {
            const response = await fetch('/api/ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) {
                const data = await response.json();
                return JSON.parse(data.choices[0].message.content);
            }
            throw new Error("Proxy error");
        } catch (e) {
            if (openaiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    return JSON.parse(data.choices[0].message.content);
                } catch (dE) { return fallbackError; }
            }
            return fallbackError;
        }
    }

    async generateNextBriefingQuestion(currentAnswers) {
        const openaiKey = MASTER_AI_KEY; // Fallback key
        const systemPrompt = `Voc√™ √© o Arquiteto de Intelig√™ncia da AURA. Entreviste o dono do neg√≥cio. Conhecido: ${JSON.stringify(currentAnswers)}. Fa√ßa UMA pergunta por vez. Se acabar, diga COMPLETE.`;

        const payload = {
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: 'Gere a pr√≥xima pergunta ou COMPLETE.' }
            ],
            temperature: 0.7,
            max_tokens: 150
        };

        try {
            const response = await fetch('/api/ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) {
                const data = await response.json();
                return data.choices?.[0]?.message?.content?.trim();
            }
            throw new Error('Proxy fail');
        } catch (e) {
            if (openaiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    return data.choices?.[0]?.message?.content?.trim();
                } catch (dE) { return "Algum outro detalhe importante?"; }
            }
            return "Algum outro detalhe importante?";
        }
    }

    async analyzeKnowledgePoint(question, answer) {
        const openaiKey = MASTER_AI_KEY;
        const systemPrompt = `Analise este ponto de conhecimento para vendas. Resposta curta (2 linhas).`;
        const payload = {
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: `Pergunta: ${question}\nResposta: ${answer}` }
            ],
            temperature: 0.5,
            max_tokens: 100
        };

        try {
            const response = await fetch('/api/ai', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) {
                const data = await response.json();
                return data.choices?.[0]?.message?.content?.trim();
            }
            throw new Error("Proxy fail");
        } catch (e) {
            if (openaiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    return data.choices?.[0]?.message?.content?.trim();
                } catch (dE) { return "Ponto estrat√©gico validado."; }
            }
            return "Ponto estrat√©gico validado.";
        }
    }
}

export default new OpenAIService();


--- FILE: src/services/rag.js ---

import { useStore } from '../store/useStore';

class RAGService {
    /**
     * Searches for relevant context based on the query (patient's last message).
     * In this initial version, it simply concatenates matching snippets from RAG sources.
     */
    async getRelevantContext(query) {
        console.log("AURA RAG: Buscando contexto para query:", query);
        const { ragSources, briefing } = useStore.getState();
        let context = "";

        if (!query) return "";

        const cleanQuery = query.toLowerCase();
        const queryWords = cleanQuery.split(/\s+/);

        // 1. Check Briefing (Core Knowledge)
        if (briefing && (cleanQuery.includes('quem') || cleanQuery.includes('clinica') || cleanQuery.includes('onde'))) {
            context += `\n[IDENTIDADE DO NEG√ìCIO]: ${briefing.substring(0, 1000)}`;
        }

        // 2. Check specialist RAG Sources (Future: Vector Search)
        let processedSources = [];
        if (Array.isArray(ragSources)) {
            processedSources = ragSources;
        } else if (ragSources && typeof ragSources === 'object') {
            processedSources = Object.values(ragSources);
        }

        processedSources.forEach(source => {
            if (!source.keywords || !source.content) return;
            const triggerWords = Array.isArray(source.keywords) ? source.keywords : [source.keywords];

            // Check if any keyword is contained in the query OR if any query word matches a keyword
            const matches = triggerWords.some(word => {
                const cleanWord = String(word).toLowerCase();
                return cleanQuery.includes(cleanWord) || queryWords.includes(cleanWord);
            });

            if (matches) {
                console.log(`AURA RAG: ‚úÖ Match encontrado! Fonte: ${source.name}`);
                context += `\n[DADO T√âCNICO ESPECIALISTA - ${source.name.toUpperCase()}]: ${source.content}`;
            }
        });

        if (!context) console.log("AURA RAG: ‚ùå Nenhum contexto relevante encontrado.");
        return context;
    }
}

export default new RAGService();


--- FILE: src/services/supabase.js ---

import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
    console.warn('AURA: Supabase credentials missing in environment variables.');
}

export const supabase = createClient(
    supabaseUrl || 'https://placeholder.supabase.co',
    supabaseAnonKey || 'placeholder'
);

console.log('AURA: Supabase client initialized');


--- FILE: src/services/whatsapp.js ---

import { useStore } from '../store/useStore';
import { io } from 'socket.io-client';
import { dedupeMessages, getJidDigits } from '../utils/messageSync';

class WhatsAppService {
    constructor() {
        this.socket = null;
        this.serverInfoCache = null;
    }

    async request(endpoint, method = 'GET', body = null) {
        const { apiUrl, apiKey } = useStore.getState();
        if (!apiUrl || !apiKey) return null;

        const headers = { 'Content-Type': 'application/json', 'apikey': apiKey };
        const baseUrl = String(apiUrl).trim().endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;
        const cleanEndpoint = endpoint.startsWith('/') ? endpoint : '/' + endpoint;
        const url = `${baseUrl}${cleanEndpoint}`;

        console.log(`AURA: Fetching ${url}`);
        try {
            const response = await fetch(url, {
                method,
                headers,
                body: body ? JSON.stringify(body) : null
            });

            if (!response.ok) {
                // Return error object instead of null so we can handle 404s
                const errorBody = await response.json().catch(() => ({}));
                return { error: true, status: response.status, ...errorBody };
            }

            return await response.json();
        } catch (e) {
            console.error("API Request Error:", e);
            return { error: true, message: e.message };
        }
    }

    parseVersion(version) {
        const [major = '0', minor = '0', patch = '0'] = String(version || '0.0.0').split('.');
        return [Number.parseInt(major, 10) || 0, Number.parseInt(minor, 10) || 0, Number.parseInt(patch, 10) || 0];
    }

    isVersionLessThan(version, minimum) {
        const current = this.parseVersion(version);
        const target = this.parseVersion(minimum);
        for (let i = 0; i < 3; i += 1) {
            if (current[i] < target[i]) return true;
            if (current[i] > target[i]) return false;
        }
        return false;
    }

    async getServerInfo(force = false) {
        if (!force && this.serverInfoCache) return this.serverInfoCache;
        try {
            const info = await this.request('/', 'GET');
            if (info && !info.error) {
                this.serverInfoCache = info;
                return info;
            }
        } catch (e) {
            console.error('AURA getServerInfo error:', e);
        }
        return null;
    }

    connectSocket() {
        const { apiUrl, apiKey, instanceName } = useStore.getState();
        if (!apiUrl || !instanceName || this.socket) return;

        console.log(`üîå Initializing Socket for ${instanceName}...`);

        // Evolution API usually exposes socket at root
        const baseUrl = String(apiUrl).trim().endsWith('/') ? apiUrl.slice(0, -1) : apiUrl;

        this.socket = io(baseUrl, {
            transports: ['websocket', 'polling'],
            query: {
                apikey: apiKey
            }
        });

        this.socket.on('connect', () => {
            console.log('‚úÖ Socket Connected!');
        });

        this.socket.on(`messages.upsert`, (payload) => {
            // Payload format: { instance, data: { ...message... }, ... }
            if (payload?.data) {
                const msg = payload.data;
                const remoteJid = msg.key?.remoteJid;

                // DEEP SCAN for Phone Number in Real-Time
                // This mimics N8N's ability to see the raw webhook
                if (remoteJid && remoteJid.includes('@lid')) {
                    // Check if message has participant with real number
                    const participant = msg.key?.participant || msg.participant;
                    const remoteJidAlt = msg.key?.remoteJidAlt || msg.remoteJidAlt;
                    if (participant && participant.includes('@s.whatsapp.net')) {
                        const extracted = participant.split('@')[0];
                        console.log(`üïµÔ∏è Socket Discovery: Found valid number ${extracted} for LID ${remoteJid}`);
                        this.setManualPhoneMapping(remoteJid, extracted);
                    }
                    if (remoteJidAlt && remoteJidAlt.includes('@s.whatsapp.net')) {
                        const extractedAlt = remoteJidAlt.split('@')[0];
                        console.log(`üïµÔ∏è Socket Discovery: Found remoteJidAlt ${extractedAlt} for LID ${remoteJid}`);
                        this.setManualPhoneMapping(remoteJid, extractedAlt);
                    }
                }

                // Real-time sync for active thread to reduce polling gaps.
                useStore.getState().appendRealtimeMessage(msg);
            }
        });
    }

    async checkConnection() {
        const { instanceName } = useStore.getState();
        if (!instanceName) return 'disconnected';

        // Ensure socket is connected
        if (!this.socket) this.connectSocket();

        try {
            const data = await this.request(`/instance/connectionState/${instanceName}`);

            if (data?.instance?.state) return data.instance.state;

            // If 404 (instance not found), returns null from request()
            // We should try to create it if it doesn't exist
            return 'disconnected';
        } catch {
            return 'disconnected';
        }
    }

    async createInstance(name) {
        if (!name) return null;
        console.log(`AURA: Creating instance ${name}...`);
        // FIX: Use proven payload for Evolution API v2
        return await this.request('/instance/create', 'POST', {
            instanceName: name,
            token: name,
            qrcode: false,
            integration: 'WHATSAPP-BAILEYS'
        });
    }

    async connectInstance() {
        const { instanceName } = useStore.getState();
        if (!instanceName) return null;

        // v2 standard: GET to connect instance
        // If 404, it means instance doesn't exist. We must CREATE it.
        try {
            const response = await this.request(`/instance/connect/${instanceName}`);

            // Check for specific 404 or error in response payload if request() swallowed it
            if (!response || (response.error && response.status === 404) || (response.response && response.response.message && response.response.message.includes('does not exist'))) {
                console.warn(`AURA: Instance ${instanceName} not found. Creating...`);
                await this.createInstance(instanceName);
                // Try connecting again after creation
                return await this.request(`/instance/connect/${instanceName}`);
            }

            return response;
        } catch (e) {
            console.error("Connect error:", e);
            return null;
        }
    }

    async logoutInstance() {
        const { instanceName } = useStore.getState();
        if (!instanceName) return null;
        // CRITICAL: Delete the instance to clear all data (chats, messages) from the backend
        // This ensures that if the user connects a different number, no old data remains.
        return await this.request(`/instance/delete/${instanceName}`, 'DELETE');
    }

    standardizeJid(jid) {
        if (!jid) return null;
        let clean = String(jid).trim();
        if (!clean.includes('@')) clean = `${clean}@s.whatsapp.net`;

        // Final sanity check: must have at least 5 digits before @
        const parts = clean.split('@');
        if (parts[0].replace(/\D/g, '').length < 5) return null;

        return clean;
    }

    getNum(jid) {
        return getJidDigits(jid);
    }

    getRelatedStoreJids(jid, chatData = null) {
        const targetNum = this.getNum(jid || chatData?.id || chatData?.remoteJid);
        if (!targetNum) return [];

        const { chats } = useStore.getState();
        if (!Array.isArray(chats)) return [];

        const related = [];
        chats.forEach((chat) => {
            const candidates = [
                chat?.id,
                chat?.jid,
                chat?.remoteJid,
                chat?.remoteJidAlt,
                chat?.sendTargetJid,
                chat?.linkedLid,
                chat?.lastMessage?.key?.remoteJid,
                chat?.lastMessage?.key?.remoteJidAlt,
            ];
            candidates.forEach((candidate) => {
                if (!candidate) return;
                if (this.getNum(candidate) === targetNum) related.push(candidate);
            });
        });

        return [...new Set(related.map((item) => this.standardizeJid(item)).filter(Boolean))];
    }

    toPhoneJid(phoneNumber) {
        const normalized = this.normalizePhoneNumber(phoneNumber);
        return normalized ? `${normalized}@s.whatsapp.net` : null;
    }

    isLidDerivedPhone(phoneNumber, lidJid) {
        const normalizedPhone = this.normalizePhoneNumber(phoneNumber);
        const lidDigits = this.getNum(lidJid);
        if (!normalizedPhone || !lidDigits) return false;
        return normalizedPhone === lidDigits;
    }

    resolveMessageTargetJids(jid, linkedJid = null, chatData = null) {
        const targets = [
            jid,
            linkedJid,
            chatData?.id,
            chatData?.jid,
            chatData?.remoteJid,
            chatData?.remoteJidAlt,
            chatData?.sendTargetJid,
            chatData?.linkedLid,
            chatData?.lastMessage?.key?.remoteJid,
            chatData?.lastMessage?.key?.remoteJidAlt,
        ].map((candidate) => this.standardizeJid(candidate)).filter(Boolean);

        targets.push(...this.getRelatedStoreJids(jid, chatData));

        const manualPhone = this.getManualPhoneMappingFromCandidates(jid, chatData);
        if (manualPhone) targets.push(this.toPhoneJid(manualPhone));

        const extractedPhone = this.extractPhoneNumber(jid, chatData);
        if (extractedPhone) targets.push(this.toPhoneJid(extractedPhone));

        return [...new Set(targets)];
    }


    async fetchMediaUrl(messageKey) {
        const { instanceName } = useStore.getState();
        if (!instanceName || !messageKey) return null;

        try {
            const data = await this.request(`/chat/getBase64FromMediaMessage/${instanceName}`, 'POST', {
                message: {
                    key: messageKey
                },
                convertToMp4: false
            });

            // Evolution API may return base64 with or without Data URI prefix
            let base64 = data?.base64 || null;

            if (!base64) return null;

            // If the base64 doesn't start with "data:", add the proper prefix
            // Evolution API typically returns audio/ogg for WhatsApp voice messages
            if (!base64.startsWith('data:')) {
                base64 = `data:audio/ogg;base64,${base64}`;
            }

            return base64;
        } catch (e) {
            console.error("Media fetch error:", e);
            return null;
        }
    }

    async fetchChats() {
        const { instanceName } = useStore.getState();
        if (!instanceName) return [];

        // v2 standard: POST to findChats
        const data = await this.request(`/chat/findChats/${instanceName}`, 'POST', {});

        // Fetch Address Book to help resolve LIDs
        const contactsList = await this.fetchContacts();
        const contactsByNumber = new Map(); // number -> display name
        contactsList.forEach(c => {
            const jid = c.id || c.jid;
            const name = (c.name || c.pushName || "").trim();
            if (jid && jid.includes('@s.whatsapp.net') && name) {
                contactsByNumber.set(this.getNum(jid), name);
            }
        });

        const list = Array.isArray(data) ? data : (data?.records || data?.chats || []);
        const getTS = (chat) => chat?.lastMessage?.messageTimestamp || chat?.messageTimestamp || chat?.conversationTimestamp || 0;
        const lidReferenceChats = list.filter((chat) => {
            const rawJid = chat?.remoteJid || chat?.jid || chat?.id || chat?.key?.remoteJid || '';
            return (
                typeof rawJid === 'string' &&
                rawJid.includes('@lid') &&
                (chat?.pushName || chat?.name || chat?.verifiedName || chat?.profilePicUrl)
            );
        });
        const lidReferenceTimestamps = lidReferenceChats.map(getTS).filter(Boolean);
        const lidRawJids = [...new Set(
            list
                .map((chat) => chat?.remoteJid || chat?.jid || chat?.id || chat?.key?.remoteJid)
                .filter((jid) => typeof jid === 'string' && jid.includes('@lid'))
        )];
        const lidVerification = await this.verifyWhatsAppNumbersBulk(lidRawJids);
        const finalMap = new Map();

        // Canonicalize each chat identity and collapse equivalent records.
        list.forEach((chat) => {
            const rawJid = chat.remoteJid || chat.jid || chat.id || chat.key?.remoteJid;
            if (!rawJid || typeof rawJid !== 'string') return;

            const baseJid = this.standardizeJid(rawJid.includes('@') ? rawJid : `${rawJid}@s.whatsapp.net`);
            if (!baseJid) return;

            const isLid = baseJid.includes('@lid');
            const isDirectPhone = baseJid.includes('@s.whatsapp.net');
            const baseDigits = this.getNum(baseJid);
            if ((isLid || isDirectPhone) && (!baseDigits || baseDigits.length < 10)) return;

            // Suppress "shadow" outbound-only unsaved phone chats created during LID routing migration.
            const messageText = chat?.lastMessage?.message?.conversation || '';
            const isShadowOutboundPhone =
                isDirectPhone &&
                chat?.isSaved === false &&
                !chat?.pushName &&
                !chat?.name &&
                !chat?.profilePicUrl &&
                chat?.lastMessage?.key?.fromMe === true &&
                String(messageText).trim().length <= 8;

            if (isShadowOutboundPhone && lidReferenceTimestamps.length > 0) {
                const ts = getTS(chat);
                const hasNearbyLidActivity = lidReferenceTimestamps.some((lidTs) => Math.abs((lidTs || 0) - (ts || 0)) <= 300);
                if (hasNearbyLidActivity) return;
            }

            const verifiedLid = lidVerification.find((item) => {
                if (!item?.jid) return false;
                return item.jid === baseJid || this.getNum(item.jid) === this.getNum(baseJid);
            });

            let stableId = baseJid;
            let sendTargetJid = baseJid;
            let linkedLid = null;
            const chatAltCandidates = [
                chat?.remoteJidAlt,
                chat?.key?.remoteJidAlt,
                chat?.lastMessage?.key?.remoteJidAlt,
                chat?.lastMessage?.remoteJidAlt,
                chat?.lastMessage?.key?.remoteJid,
            ]
                .map((candidate) => this.standardizeJid(candidate))
                .filter((candidate) => candidate?.includes('@s.whatsapp.net'));

            if (isLid) {
                linkedLid = baseJid;
                const resolvedPhoneRaw = verifiedLid?.number || this.extractPhoneNumber(baseJid, chat);
                const resolvedPhone = this.isLidDerivedPhone(resolvedPhoneRaw, baseJid) ? null : resolvedPhoneRaw;
                if (resolvedPhone) chat.phoneNumber = resolvedPhone;

                const safeAltCandidates = chatAltCandidates.filter((candidate) => {
                    const candidateDigits = this.getNum(candidate);
                    return candidateDigits && candidateDigits !== this.getNum(baseJid);
                });

                // Keep LID as stable chat identity, but prefer phone jid for sending when available.
                sendTargetJid = safeAltCandidates[0] || sendTargetJid;
                if (!sendTargetJid?.includes('@s.whatsapp.net') && verifiedLid?.jid?.includes('@s.whatsapp.net')) {
                    sendTargetJid = verifiedLid.jid;
                }
                if (!sendTargetJid?.includes('@s.whatsapp.net') && resolvedPhone) {
                    sendTargetJid = `${resolvedPhone}@s.whatsapp.net`;
                }
            }

            // Merge @lid and @s.whatsapp.net variants into one logical chat by phone number.
            const logicalPhone =
                this.getNum(sendTargetJid) ||
                this.normalizePhoneNumber(chat?.phoneNumber) ||
                null;
            if (logicalPhone && logicalPhone.length >= 10) {
                stableId = `phone:${logicalPhone}`;
            } else if (isDirectPhone && baseDigits) {
                stableId = `phone:${baseDigits}`;
            } else {
                stableId = `jid:${baseJid}`;
            }

            const enriched = {
                ...chat,
                id: stableId,
                jid: stableId,
                remoteJid: stableId,
                remoteJidAlt: chatAltCandidates[0] || null,
                sendTargetJid,
                linkedLid: linkedLid || chat.linkedLid || null,
            };

            const numberName = contactsByNumber.get(this.getNum(sendTargetJid));
            if (numberName && !(enriched.name || enriched.pushName || enriched.verifiedName)) {
                enriched.name = numberName;
                enriched.pushName = numberName;
            }
            if (verifiedLid?.name && !(enriched.name || enriched.pushName || enriched.verifiedName)) {
                enriched.name = verifiedLid.name;
                enriched.pushName = verifiedLid.name;
            }

            const existing = finalMap.get(stableId);
            if (!existing) {
                finalMap.set(stableId, enriched);
                return;
            }

            // Merge duplicate logical chats by canonical identity.
            const existingTs = getTS(existing);
            const incomingTs = getTS(enriched);
            const newest = incomingTs >= existingTs ? enriched : existing;
            const oldest = newest === existing ? enriched : existing;

            finalMap.set(stableId, {
                ...oldest,
                ...newest,
                id: stableId,
                jid: newest.jid || oldest.jid || baseJid,
                remoteJid: newest.remoteJid || oldest.remoteJid || baseJid,
                sendTargetJid: newest.sendTargetJid || oldest.sendTargetJid || baseJid,
                linkedLid: newest.linkedLid || oldest.linkedLid || null,
                unreadCount: (existing.unreadCount || 0) + (enriched.unreadCount || 0),
            });
        });

        // Sort by real activity (newest first)
        const sorted = Array.from(finalMap.values()).sort((a, b) => {
            return (getTS(b) * 1000) - (getTS(a) * 1000);
        });

        // FINAL DEDUPLICATION: Ensure one chat per Phone Number
        // Sometimes the mapping logic above might miss edge cases if LIDs and Phones don't have a direct link yet.
        console.log(`AURA: Running deduplication on ${sorted.length} chats...`);
        const uniquePhones = new Set();
        return sorted.filter(chat => {
            const rawId = chat.id || chat.jid || chat.remoteJid;
            const digits = this.getNum(rawId);

            // If it's a valid phone number (10+ digits), dedupe it
            if (digits && digits.length >= 10) {
                if (uniquePhones.has(digits)) return false;
                uniquePhones.add(digits);
                return true;
            }
            // If it's a short code or group, keep it
            return true;
        });
    }

    async fetchContacts() {
        const { instanceName } = useStore.getState();
        if (!instanceName) return [];
        try {
            // v2 standard: POST to findContacts to get address book
            const data = await this.request(`/chat/findContacts/${instanceName}`, 'POST', {});
            const list = Array.isArray(data) ? data : (data?.records || data?.contacts || []);
            return Array.isArray(list) ? list : [];
        } catch (e) {
            console.error("Error fetching contacts:", e);
            return [];
        }
    }

    async verifyWhatsAppNumbersBulk(numbersOrJids = []) {
        const { instanceName } = useStore.getState();
        if (!instanceName || !Array.isArray(numbersOrJids) || numbersOrJids.length === 0) return [];

        try {
            const response = await this.request(`/chat/whatsappNumbers/${instanceName}`, 'POST', {
                numbers: numbersOrJids,
            });

            const rawList =
                (Array.isArray(response) && response) ||
                (Array.isArray(response?.numbers) && response.numbers) ||
                (Array.isArray(response?.data) && response.data) ||
                (Array.isArray(response?.response) && response.response) ||
                (Array.isArray(response?.response?.message) && response.response.message) ||
                [];

            return rawList.map((item) => {
                const jid = item?.jid || item?.number || null;
                return {
                    exists: item?.exists !== false,
                    jid,
                    number: this.normalizePhoneNumber(item?.number || this.getNum(jid)),
                    name: item?.name || null,
                    lid: item?.lid || null,
                    raw: item,
                };
            });
        } catch (error) {
            console.error('AURA verifyWhatsAppNumbersBulk error:', error);
            return [];
        }
    }

    async verifyWhatsAppNumber(numberOrJid) {
        const list = await this.verifyWhatsAppNumbersBulk([numberOrJid]);
        return list[0] || null;
    }

    async fetchMessages(jid, linkedJid = null, chatData = null) {
        const { instanceName } = useStore.getState();
        const cleanJid = this.standardizeJid(jid);
        if (!instanceName || !cleanJid) return [];

        const tryFetch = async (targetJid, altJid = null) => {
            if (!targetJid) return [];
            try {
                const keyWhere = { remoteJid: targetJid };
                if (altJid) keyWhere.remoteJidAlt = altJid;

                const data = await this.request(`/chat/findMessages/${instanceName}`, 'POST', {
                    where: {
                        key: keyWhere,
                    },
                    offset: 500,
                    page: 1,
                });
                const list = data?.messages?.records || data?.records || data?.messages || [];
                return Array.isArray(list) ? list : [];
            } catch (e) {
                console.error(`Error fetching messages for ${targetJid}:`, e);
                return [];
            }
        };

        // 1. Fetch all candidate JIDs for this logical conversation
        const targets = this.resolveMessageTargetJids(cleanJid, linkedJid, chatData);
        let messages = [];
        for (const target of targets) {
            const partial = await tryFetch(target, chatData?.linkedLid || null);
            if (partial.length > 0) messages.push(...partial);
        }

        // 2. Fallback: Brazilian 9-digit heuristic (only if empty and no linkedJid known)
        if (messages.length === 0 && !linkedJid && cleanJid.startsWith('55')) {
            const number = cleanJid.split('@')[0];
            const alt = number.length === 13 ? number.slice(0, 4) + number.slice(5) :
                (number.length === 12 ? number.slice(0, 4) + '9' + number.slice(4) : null);
            if (alt) {
                const altMsgs = await tryFetch(`${alt}@s.whatsapp.net`);
                messages = [...messages, ...altMsgs];
            }
        }

        // 3. Final dedupe + sort
        const deduped = dedupeMessages(messages);
        return deduped.sort((a, b) => {
            const tA = a.messageTimestamp || 0;
            const tB = b.messageTimestamp || 0;
            return tB - tA;
        });
    }

    // PHONE NUMBER EXTRACTION & MANAGEMENT
    getManualPhoneMapping(jid) {
        try {
            const mappings = JSON.parse(localStorage.getItem('contactPhoneMap') || '{}');
            return mappings[jid] || null;
        } catch (e) {
            console.error('Error reading phone mappings:', e);
            return null;
        }
    }

    normalizePhoneNumber(input) {
        if (!input) return null;
        const digits = String(input).replace(/\D/g, '');
        if (!/^\d{10,15}$/.test(digits)) return null;
        return digits;
    }

    getCandidateJids(jid, chatData = null) {
        const candidates = [
            jid,
            chatData?.id,
            chatData?.jid,
            chatData?.remoteJid,
            chatData?.remoteJidAlt,
            chatData?.sendTargetJid,
            chatData?.linkedLid,
            chatData?.lastMessage?.key?.remoteJid,
            chatData?.lastMessage?.key?.remoteJidAlt,
            chatData?.lastMessage?.remoteJid,
            chatData?.lastMessage?.remoteJidAlt,
        ].filter(Boolean);

        return [...new Set(candidates)];
    }

    getManualPhoneMappingFromCandidates(jid, chatData = null) {
        const candidates = this.getCandidateJids(jid, chatData);
        for (const candidate of candidates) {
            const mapped = this.getManualPhoneMapping(candidate);
            if (mapped) return mapped;
        }
        return null;
    }

    setManualPhoneMapping(jid, phoneNumber, chatData = null) {
        try {
            const normalized = this.normalizePhoneNumber(phoneNumber);
            if (!normalized) {
                console.warn(`‚ö†Ô∏è Invalid phone mapping for ${jid}:`, phoneNumber);
                return false;
            }
            const mappings = JSON.parse(localStorage.getItem('contactPhoneMap') || '{}');
            const candidates = this.getCandidateJids(jid, chatData);
            candidates.forEach((candidate) => {
                mappings[candidate] = normalized;
            });
            localStorage.setItem('contactPhoneMap', JSON.stringify(mappings));
            console.log(`‚úÖ Saved phone mapping: [${candidates.join(', ')}] ‚Üí ${normalized}`);
            return true;
        } catch (e) {
            console.error('Error saving phone mapping:', e);
            return false;
        }
    }

    extractPhoneNumber(jid, chatData = null) {
        if (!jid) return null;

        // Priority 1: Regular phone number JID (e.g., "5531992957555@s.whatsapp.net")
        if (jid.includes('@s.whatsapp.net') && !jid.includes('@lid')) {
            const phone = jid.split('@')[0];
            // Validate it's actually a phone number (10-15 digits)
            if (/^\d{10,15}$/.test(phone)) {
                return phone;
            }
        }

        // Priority 2: Phone number attached during chat merge/resolution
        const attachedPhone = this.normalizePhoneNumber(chatData?.phoneNumber);
        if (attachedPhone) {
            console.log(`‚úÖ Using attached chat phoneNumber: ${attachedPhone}`);
            return attachedPhone;
        }

        // Priority 3: Extract from chat metadata (for @lid contacts)
        if (chatData) {
            // Check participant field (often contains the real phone number)
            const participant = chatData.lastMessage?.key?.participant ||
                chatData.lastMessage?.participant ||
                chatData.participant;

            if (participant && participant.includes('@s.whatsapp.net')) {
                const phone = participant.split('@')[0];
                if (/^\d{10,15}$/.test(phone)) {
                    console.log(`‚úÖ Extracted phone from participant: ${phone}`);
                    return phone;
                }
            }

            // Check remoteJid variations
            const remoteJid = chatData.lastMessage?.key?.remoteJid || chatData.remoteJid;
            if (remoteJid && remoteJid.includes('@s.whatsapp.net') && !remoteJid.includes('@lid')) {
                const phone = remoteJid.split('@')[0];
                if (/^\d{10,15}$/.test(phone)) {
                    console.log(`‚úÖ Extracted phone from remoteJid: ${phone}`);
                    return phone;
                }
            }

            const remoteJidAlt = chatData.lastMessage?.key?.remoteJidAlt ||
                chatData.lastMessage?.remoteJidAlt ||
                chatData.remoteJidAlt;
            if (remoteJidAlt && remoteJidAlt.includes('@s.whatsapp.net')) {
                const phone = remoteJidAlt.split('@')[0];
                if (/^\d{10,15}$/.test(phone)) {
                    console.log(`‚úÖ Extracted phone from remoteJidAlt: ${phone}`);
                    return phone;
                }
            }
        }

        // Priority 4: Manual mapping from localStorage
        const manualPhone = this.getManualPhoneMappingFromCandidates(jid, chatData);
        if (manualPhone) {
            console.log(`‚úÖ Using manual mapping: ${manualPhone}`);
            return manualPhone;
        }

        // Priority 5: No phone number found
        return null;
    }

    async ensurePhoneNumber(jid, chatData = null) {
        // 1. Try synchronous extraction first (Fastest)
        let phoneNumber = this.extractPhoneNumber(jid, chatData);
        if (phoneNumber) return phoneNumber;

        // 2. If valid chatData exists, try scanning its history via API
        if (chatData || jid) {
            console.log(`üïµÔ∏è Smart Scan: Searching phone number for ${jid}...`);

            // Fetch last 50 messages to find a participant
            const messages = await this.fetchMessages(jid, null, chatData);
            if (messages && messages.length > 0) {
                for (const msg of messages) {
                    const participant = msg.key?.participant || msg.participant;
                    const remoteJid = msg.key?.remoteJid || msg.remoteJid;
                    const remoteJidAlt = msg.key?.remoteJidAlt || msg.remoteJidAlt;

                    // Check if it's a valid phone JID
                    const potential = [participant, remoteJidAlt, remoteJid].find(
                        (p) => p && p.includes('@s.whatsapp.net') && !p.includes('@lid')
                    );

                    if (potential) {
                        const extracted = potential.split('@')[0];
                        if (/^\d{10,15}$/.test(extracted)) {
                            console.log(`‚úÖ Smart Scan FOUND: ${extracted} in message from ${new Date(msg.messageTimestamp * 1000).toLocaleString()}`);

                            // Auto-save the mapping!
                            this.setManualPhoneMapping(jid, extracted, chatData);
                            return extracted;
                        }
                    }
                }
            }

            // 3. DEEP HUNT: Search Address Book by Name (Last Resort)
            const targetName = (chatData?.name || chatData?.pushName || chatData?.verifiedName);
            if (targetName) {
                console.log(`üïµÔ∏è Deep Hunt: Searching Address Book for "${targetName}"...`);
                try {
                    const contacts = await this.fetchContacts();
                    if (Array.isArray(contacts)) {
                        const cleanName = (n) => String(n || "").toLowerCase().trim();
                        const searchName = cleanName(targetName);

                        const match = contacts.find(c => {
                            const cName = cleanName(c.name || c.pushName);
                            return cName === searchName && c.id && c.id.includes('@s.whatsapp.net') && !c.id.includes('@lid');
                        });

                        if (match) {
                            const extracted = match.id.split('@')[0];
                            console.log(`‚úÖ Deep Hunt FOUND via Contact Name: ${extracted}`);
                            this.setManualPhoneMapping(jid, extracted, chatData);
                            return extracted;
                        }
                    }
                } catch (e) {
                    console.error("Deep Hunt Error:", e);
                }
            }
        }

        // 4. Stop here and ask for manual mapping in UI
        return null;
    }

    getSendHints(chatData = null) {
        if (!chatData) return [];
        const hints = [
            chatData?.remoteJidAlt,
            chatData?.sendTargetJid,
            chatData?.lastMessage?.key?.remoteJidAlt,
            chatData?.lastMessage?.remoteJidAlt,
            chatData?.lastMessage?.key?.participant,
            chatData?.participant,
        ]
            .map((candidate) => this.standardizeJid(candidate))
            .filter((candidate) => candidate && candidate.includes('@s.whatsapp.net'));

        return [...new Set(hints)];
    }

    buildSendCandidates({ targetJid, linkedLid, verifiedJid, phoneNumber, lidContext, sendHints = [] }) {
        const candidates = [];
        const push = (value) => {
            if (!value) return;
            candidates.push(String(value).trim());
        };

        // Evolution-friendly order: LID route first when available.
        if (lidContext) {
            push(linkedLid);
            push(targetJid);
            push(verifiedJid);
            sendHints.forEach(push);

            return [...new Set(candidates.filter(Boolean))];
        }

        push(targetJid);
        push(verifiedJid);
        sendHints.forEach(push);

        const normalizedPhone = this.normalizePhoneNumber(phoneNumber);
        if (normalizedPhone) {
            push(normalizedPhone);
            push(`${normalizedPhone}@s.whatsapp.net`);
        }

        // If target is a phone jid, keep both phone and jid variants.
        if (targetJid?.includes('@s.whatsapp.net')) {
            const digits = this.normalizePhoneNumber(targetJid.split('@')[0]);
            if (digits) {
                push(digits);
                push(`${digits}@s.whatsapp.net`);
            }
        }

        return [...new Set(candidates.filter(Boolean))];
    }

    async sendTextWithFallback(instanceName, text, candidates = []) {
        const queue = [...new Set((candidates || []).filter(Boolean))];
        const attemptedSet = new Set();
        let lastFailure = null;
        let pointer = 0;

        while (pointer < queue.length) {
            const candidate = queue[pointer++];
            if (attemptedSet.has(candidate)) continue;
            attemptedSet.add(candidate);

            const result = await this.request(`/message/sendText/${instanceName}`, 'POST', {
                number: candidate,
                text
            });

            const existencePayload =
                result?.response?.message?.[0] ||
                result?.response?.message ||
                result?.message?.[0] ||
                result?.message ||
                null;

            const notFound = existencePayload?.exists === false;
            if (!notFound) {
                return { result, attempted: candidate };
            }

            lastFailure = { result, attempted: candidate };

            // If LID route fails, ask Evolution for canonical routing and enqueue returned targets.
            if (String(candidate).includes('@lid')) {
                const verify = await this.verifyWhatsAppNumber(candidate);
                const extraCandidates = [];
                if (verify?.jid) extraCandidates.push(verify.jid);
                if (verify?.exists && verify?.number) {
                    extraCandidates.push(verify.number);
                    extraCandidates.push(`${verify.number}@s.whatsapp.net`);
                }

                for (const extra of extraCandidates) {
                    if (extra && !attemptedSet.has(extra) && !queue.includes(extra)) {
                        queue.push(extra);
                    }
                }
            }
        }

        return lastFailure || { result: null, attempted: queue[0] || null };
    }

    persistSuccessfulRoute(baseJid, attempted, chatData = null) {
        const attemptedJid = this.standardizeJid(attempted);
        if (!attemptedJid) return;

        const attemptedPhone = this.extractPhoneNumber(attemptedJid, chatData);
        if (attemptedPhone) {
            this.setManualPhoneMapping(baseJid, attemptedPhone, chatData);
            if (chatData?.linkedLid) this.setManualPhoneMapping(chatData.linkedLid, attemptedPhone, chatData);
        }

        const state = useStore.getState();
        const currentChats = Array.isArray(state.chats) ? state.chats : [];
        const baseNum = this.getNum(baseJid || chatData?.id || chatData?.remoteJid);
        const attemptedNum = this.getNum(attemptedJid);

        if (!baseNum && !attemptedNum) return;

        const updatedChats = currentChats.map((chat) => {
            const chatNums = [
                chat?.id,
                chat?.jid,
                chat?.remoteJid,
                chat?.linkedLid,
                chat?.sendTargetJid,
                chat?.remoteJidAlt,
            ].map((value) => this.getNum(value)).filter(Boolean);

            const isSameLogicalChat =
                (baseNum && chatNums.includes(baseNum)) ||
                (attemptedNum && chatNums.includes(attemptedNum));

            if (!isSameLogicalChat) return chat;

            return {
                ...chat,
                sendTargetJid: attemptedJid,
                remoteJidAlt: attemptedJid.includes('@s.whatsapp.net') ? attemptedJid : (chat?.remoteJidAlt || null),
                phoneNumber: attemptedPhone || chat?.phoneNumber,
            };
        });

        state.setChats(updatedChats);
        const activeChat = state.activeChat;
        if (activeChat) {
            const activeNum = this.getNum(activeChat?.id || activeChat?.remoteJid || activeChat?.jid);
            if (activeNum && (activeNum === baseNum || activeNum === attemptedNum)) {
                useStore.setState({
                    activeChat: {
                        ...activeChat,
                        sendTargetJid: attemptedJid,
                        remoteJidAlt: attemptedJid.includes('@s.whatsapp.net') ? attemptedJid : (activeChat?.remoteJidAlt || null),
                        phoneNumber: attemptedPhone || activeChat?.phoneNumber,
                    },
                });
            }
        }
    }

    async sendMessage(jid, text, chatData = null) {
        const { instanceName, chats } = useStore.getState();
        if (!instanceName || !jid || !text) return null;
        let targetJid = chatData?.sendTargetJid || jid;
        const isLidJid = targetJid.includes('@lid');
        const lidContextJid = isLidJid ? targetJid : (chatData?.linkedLid || null);
        const isDirectPhoneJid = targetJid.includes('@s.whatsapp.net') && !targetJid.includes('@lid');
        let lidVerification = null;

        // Fetch complete chat data from store if not provided
        if (!chatData && chats) {
            chatData = chats.find(c => (c.id === jid || c.remoteJid === jid || c.jid === jid));
        }

        // CRITICAL: Extract phone number with Smart Scan Fallback
        let phoneNumber = await this.ensurePhoneNumber(targetJid, chatData);
        const sendHints = this.getSendHints(chatData);

        // For direct number chats, ask Evolution to validate/normalize before send.
        if (isDirectPhoneJid && !lidContextJid) {
            const directDigits = this.normalizePhoneNumber(targetJid.split('@')[0]);
            const verify = await this.verifyWhatsAppNumber(directDigits || targetJid);

            if (verify?.exists === false) {
                return {
                    error: true,
                    invalidRecipient: true,
                    needsPhoneNumber: false,
                    message: `N√∫mero ${directDigits || targetJid} n√£o existe no WhatsApp ou est√° indispon√≠vel.`,
                    attemptedPhone: directDigits || phoneNumber,
                    jid,
                };
            }

            if (verify?.number) phoneNumber = verify.number;
        }

        // For LID chats, try official verification to resolve phone.
        if (lidContextJid) {
            lidVerification = await this.verifyWhatsAppNumber(lidContextJid);
            if (lidVerification?.exists && lidVerification?.number) {
                phoneNumber = lidVerification.number;
                this.setManualPhoneMapping(lidContextJid, lidVerification.number, chatData);
            }

            // Guard against fake @s route derived from the same LID digits.
            if (
                targetJid?.includes('@s.whatsapp.net') &&
                this.isLidDerivedPhone(this.getNum(targetJid), lidContextJid) &&
                lidVerification?.exists !== true
            ) {
                targetJid = lidContextJid;
            }
        }

        const sendCandidates = this.buildSendCandidates({
            targetJid,
            linkedLid: lidContextJid,
            verifiedJid: lidVerification?.jid || null,
            phoneNumber,
            lidContext: Boolean(lidContextJid),
            sendHints,
        });

        const hasTrustedPhoneRoute = sendCandidates.some((candidate) => {
            const normalized = this.standardizeJid(candidate);
            return normalized?.includes('@s.whatsapp.net');
        });

        // Preflight guard for legacy Evolution versions that cannot resolve @lid sends reliably.
        if (lidContextJid && !hasTrustedPhoneRoute) {
            const serverInfo = await this.getServerInfo();
            const serverVersion = serverInfo?.version || null;
            if (serverVersion && this.isVersionLessThan(serverVersion, '2.3.7')) {
                return {
                    error: true,
                    invalidRecipient: true,
                    needsPhoneNumber: false,
                    legacyLidLimitation: true,
                    message: `Envio bloqueado para contato @lid nesta vers√£o da Evolution (${serverVersion}). Atualize para >= 2.3.7 para envio confi√°vel em contatos desconhecidos.`,
                    attemptedPhone: targetJid,
                    jid,
                };
            }
        }

        if (sendCandidates.length === 0) {
            return {
                error: true,
                message: `‚ùå Destinat√°rio n√£o resolvido para envio.`,
                needsPhoneNumber: !(isDirectPhoneJid || isLidJid),
                suggestedPhone: this.normalizePhoneNumber(jid?.split('@')[0]),
                jid,
            };
        }

        const { result, attempted } = await this.sendTextWithFallback(instanceName, text, sendCandidates);

        // Check for "number doesn't exist" error
        if (result?.response?.message?.[0]?.exists === false) {
            const isLidAttempt = String(attempted || '').includes('@lid') || String(targetJid || '').includes('@lid');
            let lidHint = '';
            if (isLidAttempt) {
                const serverInfo = await this.getServerInfo();
                const serverVersion = serverInfo?.version || null;
                if (serverVersion && this.isVersionLessThan(serverVersion, '2.3.7')) {
                    lidHint = `\n\nServidor Evolution ${serverVersion} detectado. Essa vers√£o tem limita√ß√£o conhecida com contatos @lid. Atualize para >= 2.3.7 para envio confi√°vel em contatos desconhecidos.`;
                }
            }
            return {
                error: true,
                message: `N√∫mero ${attempted || phoneNumber} n√£o existe no WhatsApp ou n√£o est√° acess√≠vel.${lidHint}`,
                needsPhoneNumber: !(isDirectPhoneJid || isLidJid),
                invalidRecipient: isDirectPhoneJid || isLidJid,
                attemptedPhone: attempted || phoneNumber,
                suggestedPhone: this.normalizePhoneNumber(jid?.split('@')[0]),
                jid
            };
        }

        this.persistSuccessfulRoute(jid, attempted, chatData);
        return result;
    }

    async sendMedia(jid, file, caption = '', isAudio = false) {
        const { instanceName } = useStore.getState();
        if (!instanceName || !jid || !file) return null;

        try {
            // Strip internal prefixes from our deduplication logic
            let rawJid = String(jid).replace(/^(phone:|jid:)/, '');
            const cleanJid = this.standardizeJid(rawJid);

            if (!cleanJid) return null;

            // Convert file to base64
            const base64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const result = reader.result;
                    // Remove the data:*/*;base64, prefix
                    const base64String = result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });

            // Determine media type
            let mediatype = 'document';
            if (isAudio || file.type.startsWith('audio/')) mediatype = 'audio';
            else if (file.type.startsWith('image/')) mediatype = 'image';
            else if (file.type.startsWith('video/')) mediatype = 'video';

            const payload = {
                number: cleanJid,
                mediatype,
                mimetype: file.type || 'audio/mp4',
                caption: caption || file.name,
                fileName: file.name,
                media: base64
            };

            // Options for Audio PTT (Voice Note)
            if (mediatype === 'audio') {
                payload.ptt = true;     // Evolution v1 legacy
                payload.options = {     // Evolution v2
                    ptt: true,
                    delay: 1200,
                    presence: 'recording'
                };
            } else {
                payload.options = {
                    delay: 1200,
                    presence: 'composing'
                };
            }

            return await this.request(`/message/sendMedia/${instanceName}`, 'POST', payload);
        } catch (e) {
            console.error("Send Media Error:", e);
            return null;
        }
    }
}

export default new WhatsAppService();


--- FILE: src/store/useStore.js ---

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import {
    dedupeMessages,
    getJidDigits,
    getMessageIdentity,
    reconcileMessages,
    sortMessagesDesc,
} from '../utils/messageSync';

// Helper to extract number from JID for safe comparison
const getChatKey = (jid) => getJidDigits(jid);

export const useStore = create(
    persist(
        (set, get) => ({
            apiUrl: import.meta.env.VITE_API_URL || 'https://api.voxeflow.com',
            apiKey: import.meta.env.VITE_API_KEY || '',
            instanceName: import.meta.env.VITE_INSTANCE_NAME || 'VoxeFlow',
            briefing: '', // V7: Start empty to trigger interactive briefing
            knowledgeBase: [], // Start empty for clean onboarding
            ragSources: [], // AURA v11: Clean state - RAG dependent on user input only

            isConnected: false,
            currentView: 'dashboard',
            chats: [],
            activeChat: null,
            messages: [],
            lastFetchedJid: null,
            pendingOutgoing: {},

            // CRM State - AURA Gold Palette
            tags: [
                { id: 'novo', name: 'Novo Lead', icon: 'üÜï', color: '#C5A059' },
                { id: 'qualificado', name: 'Qualificado', icon: '‚úÖ', color: '#d4af6a' },
                { id: 'proposta', name: 'Proposta Enviada', icon: 'üìã', color: '#af8a43' },
                { id: 'agendado', name: 'Agendado', icon: 'üìÖ', color: '#c09850' },
                { id: 'fechado', name: 'Fechado', icon: 'üí∞', color: '#e0c080' },
                { id: 'perdido', name: 'Perdido', icon: '‚ùå', color: '#8a6d3a' }
            ],
            chatTags: {}, // { chatId: tagId }
            chatNextSteps: {}, // { chatId: { steps: [], priority: '', reasoning: '' } }

            // AURA v11: Knowledge Loop
            managerPhone: '', // The specialist/manager WhatsApp number
            pendingGaps: {}, // { gapId: { chatId, question, timestamp } }

            setConfig: (config) => set((state) => ({ ...state, ...config })),
            setChats: (chats) => {
                console.log(`AURA: Updating store with ${chats?.length || 0} chats`);
                set({ chats });
            },

            setActiveChat: (chat) => {
                console.log("AURA: Setting active chat:", chat?.id);
                set({ activeChat: chat, messages: [], lastFetchedJid: null });
            },

            clearMessages: () => set({ messages: [], lastFetchedJid: null }),

            setMessages: (jid, messages) => {
                const currentActive = get().activeChat;
                if (!currentActive) return;

                const activeJid = currentActive.id || currentActive.remoteJid;

                // Use numbers-only comparison for maximum safety
                if (getJidDigits(activeJid) === getJidDigits(jid)) {
                    console.log(`AURA: Updating messages for ${jid} (${messages?.length || 0} msgs)`);
                    const chatKey = getChatKey(activeJid);
                    const pending = get().pendingOutgoing[chatKey] || [];
                    const { merged, stillPending } = reconcileMessages(messages || [], pending, 30 * 60 * 1000);

                    set((state) => ({
                        messages: merged,
                        lastFetchedJid: jid,
                        pendingOutgoing: { ...state.pendingOutgoing, [chatKey]: stillPending },
                    }));
                } else {
                    console.warn(`AURA: Blocked message leak from ${jid} to ${activeJid}`);
                }
            },

            appendPendingOutgoing: (jid, text, serverRecord = null) => {
                const state = get();
                const active = state.activeChat;
                if (!jid || !text?.trim()) return;

                const nowMs = Date.now();
                const outgoing = serverRecord?.key ? {
                    ...serverRecord,
                    __local: true,
                    __createdAt: nowMs,
                } : {
                    key: {
                        id: `local-${nowMs}-${Math.random().toString(36).slice(2, 8)}`,
                        fromMe: true,
                        remoteJid: jid,
                    },
                    messageTimestamp: Math.floor(nowMs / 1000),
                    message: { conversation: text.trim() },
                    __local: true,
                    __createdAt: nowMs,
                };

                const chatKey = getChatKey(jid);
                const currentPending = state.pendingOutgoing[chatKey] || [];
                const nextPending = dedupeMessages([outgoing, ...currentPending]);

                const activeJid = active?.id || active?.remoteJid;
                const shouldAppendToVisible = activeJid && getJidDigits(activeJid) === getJidDigits(jid);
                const nextVisible = shouldAppendToVisible
                    ? sortMessagesDesc(dedupeMessages([outgoing, ...state.messages]))
                    : state.messages;

                set((prev) => ({
                    messages: nextVisible,
                    pendingOutgoing: {
                        ...prev.pendingOutgoing,
                        [chatKey]: nextPending,
                    },
                }));
            },

            appendRealtimeMessage: (record) => {
                const state = get();
                const active = state.activeChat;
                if (!active || !record?.key) return;

                const activeNums = [
                    active.id,
                    active.remoteJid,
                    active.jid,
                    active.linkedLid,
                ].map(getJidDigits).filter(Boolean);

                const recordNums = [
                    record.key?.remoteJid,
                    record.remoteJid,
                    record.key?.participant,
                    record.participant,
                ].map(getJidDigits).filter(Boolean);

                const belongsToActive = record.key?.fromMe || recordNums.some((num) => activeNums.includes(num));
                if (!belongsToActive) return;

                const incomingFp = getMessageIdentity(record);
                const exists = state.messages.some((item) => getMessageIdentity(item) === incomingFp);
                if (exists) return;

                // AUTO-TAGGING: If this chat has no tag, assign the first one (Novo Lead)
                const chatId = record.key?.remoteJid || record.remoteJid;
                if (chatId && !state.chatTags[chatId] && state.tags.length > 0) {
                    // Check if it's already in the chats list to avoid re-tagging known errors, but generally safe
                    console.log(`AURA CRM: Auto-tagging new lead ${chatId} to ${state.tags[0].name}`);
                    set(prev => ({
                        chatTags: { ...prev.chatTags, [chatId]: prev.tags[0].id }
                    }));
                }

                set({ messages: [record, ...state.messages] });
            },

            setIsConnected: (isConnected) => set({ isConnected }),
            setCurrentView: (view) => set({ currentView: view }),

            // FINAL GHOST FIX: Centralized view switching with guaranteed cleanup
            switchView: (viewName) => {
                console.log(`AURA: Switching view to ${viewName}, clearing active state`);
                set({
                    currentView: viewName,
                    activeChat: null,
                    messages: [],
                    lastFetchedJid: null
                });
            },

            // ACTION: Logout and Clear State
            logout: () => {
                console.log('AURA: Logging out and clearing data...');
                set({
                    isConnected: false,
                    chats: [],
                    messages: [],
                    activeChat: null,
                    lastFetchedJid: null,
                    chatTags: {}, // Optional: keep tags or clear? Better clear for privacy.
                    chatNextSteps: {}
                });
                localStorage.removeItem('auth_token');
                localStorage.removeItem('aura-storage'); // Nuke state persistence
            },

            // CRM ACTIONS
            addCRMColumn: (name) => set(state => {
                const newId = `col-${Date.now()}`;
                return {
                    tags: [...state.tags, { id: newId, name, icon: 'üìÅ', color: '#86868b' }]
                };
            }),

            updateCRMColumn: (id, updates) => set(state => ({
                tags: state.tags.map(t => t.id === id ? { ...t, ...updates } : t)
            })),

            // CRM Actions
            setTag: (chatId, tagId) => set(state => ({
                chatTags: { ...state.chatTags, [chatId]: tagId }
            })),

            setKnowledgeBase: (knowledgeBase) => set({ knowledgeBase }),

            setNextSteps: (chatId, data) => set(state => ({
                chatNextSteps: { ...state.chatNextSteps, [chatId]: data }
            })),

            resetBrain: () => {
                console.log('AURA: Performing lobotomy (Reset Brain)...');
                set({
                    knowledgeBase: [],
                    briefing: '',
                    ragSources: [],
                    currentView: 'interview' // Force back to interview mode
                });
            },

            getChatsWithTag: (tagId) => {
                const state = get();
                return state.chats.filter(c => {
                    const jid = c.remoteJid || c.jid || c.id;
                    return state.chatTags[jid] === tagId;
                });
            },

            // COMMERCIAL: Add Lead from Landing Page
            addLead: (leadData) => {
                console.log('AURA CRM: Adding new lead from Web:', leadData);
                const state = get();
                const nowMs = Date.now();
                const leadId = `lead-${nowMs}`; // Virtual JID
                const leadName = leadData.name || 'Novo Lead Web';

                // 1. Create Virtual Chat
                const newChat = {
                    id: leadId,
                    remoteJid: leadId, // Virtual JID
                    name: leadName,
                    profilePicUrl: null,
                    unreadCount: 1,
                    messageTimestamp: Math.floor(nowMs / 1000),
                    __isVirtual: true,
                    __source: 'landing_page',
                    __plan: leadData.plan
                };

                // 2. Create Initial Message (The "Hello")
                const initialMsg = {
                    key: {
                        remoteJid: leadId,
                        fromMe: false, // It's from the lead
                        id: `msg-${nowMs}`
                    },
                    message: {
                        conversation: `Ol√°! Tenho interesse no plano ${leadData.plan.toUpperCase()}.`
                    },
                    messageTimestamp: Math.floor(nowMs / 1000),
                    pushName: leadName
                };

                // 3. Update State: Add Chat, Add Message, Tag as "Novo Lead"
                set(prev => {
                    const novoLeadTagId = prev.tags.find(t => t.name === 'Novo Lead')?.id || prev.tags[0]?.id;

                    return {
                        chats: [newChat, ...prev.chats],
                        messages: state.activeChat?.id === leadId ? [initialMsg] : [], // Only show if active (unlikely)
                        chatTags: { ...prev.chatTags, [leadId]: novoLeadTagId },
                        // Optional: trigger AI analysis immediately?
                    };
                });

                // 4. Force inject message into history for persistence
                // We re-use appendRealtimeMessage logic or just manual inject if simpler
                // For now, let's trust the chat object creation, but we need the message in the "messages" store if we open it. 
                // Actually, `messages` store is only for ACTIVE chat. So we just need to ensure it's loaded when clicked.
                // We can't easily inject into "history" without a DB, but we can rely on `chats.lastMessage` for preview.

                // Update newChat with lastMessage for preview
                newChat.lastMessage = initialMsg;
                set(prev => ({ chats: [newChat, ...prev.chats.filter(c => c.id !== leadId)] }));
            },
        }),
        {
            name: 'aura-storage',
            // PERSIST chats so they don't disappear on refresh
            partialize: (state) => ({
                apiUrl: state.apiUrl,
                apiKey: state.apiKey,
                instanceName: state.instanceName,
                briefing: state.briefing,
                knowledgeBase: state.knowledgeBase,
                ragSources: state.ragSources,
                currentView: state.currentView,
                chats: state.chats,
                tags: state.tags, // NOW PERSISTED FOR CUSTOMIZATION
                chatTags: state.chatTags, // Persist tags
                chatNextSteps: state.chatNextSteps, // Persist AI suggestions
                managerPhone: state.managerPhone,
                pendingGaps: state.pendingGaps
            }),
        }
    )
);


--- FILE: src/utils/chatArea.js ---

export function getClientNameForAi(activeChat) {
    const rawName = activeChat?.name || "";
    const isNumeric = /^\d+$/.test(rawName.replace(/\D/g, ""));
    return (isNumeric || rawName.includes("@") || !rawName) ? "Cliente" : rawName;
}

export function getMessageText(record) {
    const msg = record?.message || {};
    return (
        msg.conversation ||
        msg.extendedTextMessage?.text ||
        msg.imageMessage?.caption ||
        msg.videoMessage?.caption ||
        record?.content ||
        record?.text ||
        ""
    );
}

export function buildStructuredHistory(messages = []) {
    return messages
        .slice(-15)
        .map((record) => {
            const isMe = record?.key?.fromMe || record?.fromMe;
            return {
                role: isMe ? "assistant" : "user",
                content: getMessageText(record),
            };
        })
        .filter((item) => item.content.trim() !== "");
}

export function getLastClientText(messages = []) {
    const lastClientMsg = [...messages].reverse().find((record) => !(record?.key?.fromMe || record?.fromMe));
    return getMessageText(lastClientMsg);
}

export function deriveAnalysisData(aiText = "") {
    const lowerAi = aiText.toLowerCase();
    let level = "Consciente da Solu√ß√£o";
    let intent = "Intera√ß√£o Din√¢mica";
    let strategy = "Persuas√£o Adaptativa";

    if (lowerAi.includes("agenda") || lowerAi.includes("hor√°rio")) intent = "Agendamento";
    if (lowerAi.includes("pre√ßo") || lowerAi.includes("valor")) intent = "Financeiro";

    return { level, intent, strategy };
}

export function resolveRenderedMessage(record) {
    const msg = record?.message || {};
    const content = getMessageText(record);

    if (content) {
        return { displayContent: content, mediaType: null, transcription: null, imageCaption: null };
    }

    if (msg.audioMessage) {
        const transcription =
            msg.audioMessage?.contextInfo?.transcription ||
            msg.audioMessage?.transcription ||
            record?.transcription ||
            null;
        return { displayContent: "", mediaType: "audio", transcription, imageCaption: null };
    }

    if (msg.imageMessage) {
        return {
            displayContent: "",
            mediaType: "image",
            transcription: null,
            imageCaption: msg.imageMessage.caption || null,
        };
    }

    if (msg.videoMessage) return { displayContent: "(V√≠deo üé•)", mediaType: null, transcription: null, imageCaption: null };
    if (msg.documentMessage) return { displayContent: "(Documento üìÑ)", mediaType: null, transcription: null, imageCaption: null };
    if (msg.stickerMessage) return { displayContent: "(Figurinha ‚ú®)", mediaType: null, transcription: null, imageCaption: null };
    if (msg.locationMessage) return { displayContent: "(Localiza√ß√£o üìç)", mediaType: null, transcription: null, imageCaption: null };
    if (msg.contactMessage) return { displayContent: "(Contato üë§)", mediaType: null, transcription: null, imageCaption: null };

    return { displayContent: "(M√≠dia)", mediaType: null, transcription: null, imageCaption: null };
}


--- FILE: src/utils/chatList.js ---

import { formatJid } from './formatter';

export function getChatJid(chat) {
    return chat?.remoteJid || chat?.jid || chat?.id;
}

export function getChatTimestampMs(chat) {
    const ts = chat?.lastMessage?.messageTimestamp || chat?.messageTimestamp || chat?.conversationTimestamp || 0;
    return ts * 1000;
}

export function getChatDisplayName(chat) {
    return [
        chat?.name,
        chat?.pushName,
        chat?.verifiedName,
        chat?.lastMessage?.pushName,
        chat?.lastMessage?.key?.participant,
    ].find((name) => name && name !== 'Voc√™' && !name.includes('@lid'));
}

export function getChatAvatar(chat) {
    return chat?.profilePicUrl || chat?.profilePictureUrl || chat?.profile || chat?.avatar || null;
}

export function getChatPreview(chat, { includeAudioTranscription = false } = {}) {
    const msg = chat?.lastMessage?.message || chat?.message || {};

    const content =
        msg.conversation ||
        msg.extendedTextMessage?.text ||
        msg.imageMessage?.caption ||
        chat?.lastMessage?.content ||
        '';

    if (content) return content.length > 35 ? `${content.substring(0, 35)}...` : content;

    if (msg.audioMessage) {
        if (includeAudioTranscription) {
            const transcription = msg.audioMessage?.contextInfo?.transcription || msg.audioMessage?.transcription;
            return transcription ? `üéµ ${transcription}` : 'üéµ √Åudio';
        }
        return 'üéµ √Åudio';
    }
    if (msg.imageMessage) return 'üì∏ Imagem';
    if (msg.videoMessage) return 'üé• V√≠deo';
    if (msg.documentMessage) return 'üìÑ Documento';
    if (msg.stickerMessage) return '‚ú® Figurinha';

    return formatJid(getChatJid(chat));
}


--- FILE: src/utils/chatStorage.js ---

const ARCHIVED_CHATS_KEY = 'archived_chats';
export const ARCHIVED_CHATS_CHANGED_EVENT = 'archived-chats:changed';

function readArchivedChats() {
    try {
        const parsed = JSON.parse(localStorage.getItem(ARCHIVED_CHATS_KEY) || '[]');
        return Array.isArray(parsed) ? parsed : [];
    } catch (error) {
        console.error('AURA chatStorage parse error:', error);
        return [];
    }
}

function notifyArchivedChatsChanged() {
    window.dispatchEvent(new CustomEvent(ARCHIVED_CHATS_CHANGED_EVENT));
}

export function getArchivedChats() {
    return readArchivedChats();
}

export function isChatArchived(chatId) {
    return getArchivedChats().includes(chatId);
}

export function archiveChat(chatId) {
    const archived = getArchivedChats();
    if (archived.includes(chatId)) return false;
    archived.push(chatId);
    localStorage.setItem(ARCHIVED_CHATS_KEY, JSON.stringify(archived));
    notifyArchivedChatsChanged();
    return true;
}

export function unarchiveChat(chatId) {
    const archived = getArchivedChats();
    const updated = archived.filter((id) => id !== chatId);
    if (updated.length === archived.length) return false;
    localStorage.setItem(ARCHIVED_CHATS_KEY, JSON.stringify(updated));
    notifyArchivedChatsChanged();
    return true;
}


--- FILE: src/utils/connectModal.js ---

export function toWsUrl(apiUrl = "") {
    return apiUrl.replace("https://", "wss://").replace("http://", "ws://");
}

export function extractQrCodeBase64(payload) {
    const data = payload?.data || payload;
    let qrCodeData = null;

    if (data?.qrcode) {
        if (typeof data.qrcode === "string") {
            qrCodeData = data.qrcode;
        } else if (data.qrcode.base64) {
            qrCodeData = data.qrcode.base64;
        }
    } else if (data?.base64) {
        qrCodeData = data.base64;
    }

    if (!qrCodeData || typeof qrCodeData !== "string") return null;
    return qrCodeData.replace(/^data:image\/[a-z]+;base64,/, "");
}


--- FILE: src/utils/formatter.js ---

export const formatJid = (jid) => {
    if (!jid) return '';
    const raw = String(jid);

    // Handle @lid (Linked ID)
    if (raw.includes('@lid')) {
        const idPart = raw.split('@')[0];
        // Only attempt phone formatting if it's likely a real number mapped to a JID
        // Otherwise, return as a clean ID string to avoid "+42" misidentification
        return idPart;
    }

    const number = raw.split('@')[0].replace(/\D/g, '');

    // Brazilian Numbers (55...)
    if (number.startsWith('55')) {
        let ddd = number.slice(2, 4);
        let part = number.slice(4);

        // Add 9th digit if missing (common in old WA JIDs for Brazilian mobile)
        // Mobile numbers in Brazil have 11 digits (DDD + 9 + 8 digits)
        // If we only have 10 digits after '55' (DDD + 8 digits), it's likely missing the 9
        if (part.length === 8) {
            part = '9' + part;
        }

        if (part.length === 9) {
            return `(${ddd}) ${part.slice(0, 5)}-${part.slice(5)}`;
        }

        if (part.length === 8) {
            return `(${ddd}) ${part.slice(0, 4)}-${part.slice(4)}`;
        }
    }

    // Default formatting for other numbers
    if (number.length > 10) {
        return `+${number.slice(0, 2)} ${number.slice(2, 4)} ${number.slice(4, 9)}-${number.slice(9)}`;
    }

    return number;
};

export const formatMessageTime = (timestamp) => {
    if (!timestamp) return '';
    const date = new Date(timestamp * 1000); // WhatsApp uses seconds usually, but let's check input
    // If timestamp is huge (ms), don't multiply. If small (seconds), multiply.
    // Standard JS Date takes ms.
    const time = (String(timestamp).length > 11) ? new Date(timestamp) : new Date(timestamp * 1000);

    return time.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
};

export const getMessageDateGroup = (timestamp) => {
    if (!timestamp) return 'Data Desconhecida';
    const date = (String(timestamp).length > 11) ? new Date(timestamp) : new Date(timestamp * 1000);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
        return 'Hoje';
    } else if (date.toDateString() === yesterday.toDateString()) {
        return 'Ontem';
    } else {
        return date.toLocaleDateString('pt-BR');
    }
};


--- FILE: src/utils/messageSync.js ---

export function getJidDigits(jid) {
    return String(jid || '').split('@')[0].replace(/\D/g, '');
}

export function getMessageIdentity(record) {
    const keyId = record?.key?.id;
    if (keyId) return `key:${keyId}`;

    const ts = String(record?.messageTimestamp || '');
    const fromMe = record?.key?.fromMe || record?.fromMe ? '1' : '0';
    const remote = getJidDigits(record?.key?.remoteJid || record?.remoteJid || '');
    const participant = getJidDigits(record?.key?.participant || record?.participant || '');
    const text =
        record?.message?.conversation ||
        record?.message?.extendedTextMessage?.text ||
        record?.message?.imageMessage?.caption ||
        record?.message?.videoMessage?.caption ||
        record?.message?.audioMessage?.caption ||
        '';

    return `fp:${fromMe}:${ts}:${remote}:${participant}:${text}`;
}

export function sortMessagesDesc(messages = []) {
    return [...messages].sort((a, b) => (b?.messageTimestamp || 0) - (a?.messageTimestamp || 0));
}

export function dedupeMessages(messages = []) {
    const seen = new Set();
    const result = [];

    for (const item of messages) {
        const id = getMessageIdentity(item);
        if (seen.has(id)) continue;
        seen.add(id);
        result.push(item);
    }

    return result;
}

export function reconcileMessages(serverMessages = [], pendingMessages = [], pendingTtlMs = 30 * 60 * 1000) {
    const merged = sortMessagesDesc(dedupeMessages([...(serverMessages || []), ...(pendingMessages || [])]));
    const serverIds = new Set((serverMessages || []).map(getMessageIdentity));
    const threshold = Date.now() - pendingTtlMs;

    const stillPending = (pendingMessages || []).filter((item) => {
        const existsInServer = serverIds.has(getMessageIdentity(item));
        const isRecent = (item?.__createdAt || 0) > threshold;
        return !existsInServer && isRecent;
    });

    return { merged, stillPending };
}

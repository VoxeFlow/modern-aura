import { createClient } from '@supabase/supabase-js';

function json(data, status = 200) {
    return new Response(JSON.stringify(data), {
        status,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
        },
    });
}

function getEnvOrThrow(env, keys) {
    for (const key of keys) {
        const value = env[key];
        if (value) return value;
    }
    throw new Error(`Variável ausente: ${keys.join(' ou ')}`);
}

function decodeBase64Url(value) {
    const normalized = String(value || '').replace(/-/g, '+').replace(/_/g, '/');
    const padded = normalized + '='.repeat((4 - (normalized.length % 4)) % 4);
    return atob(padded);
}

async function verifyLegacyJwt(token, secret) {
    if (!secret) return false;
    const parts = String(token || '').split('.');
    if (parts.length !== 3) return false;
    const [headerB64, payloadB64, signatureB64] = parts;

    const key = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(secret),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['verify']
    );

    const dataToVerify = new TextEncoder().encode(`${headerB64}.${payloadB64}`);
    const signatureBytes = Uint8Array.from(decodeBase64Url(signatureB64), (ch) => ch.charCodeAt(0));
    const isValid = await crypto.subtle.verify('HMAC', key, signatureBytes, dataToVerify);
    if (!isValid) return false;

    const payload = JSON.parse(decodeBase64Url(payloadB64));
    const now = Math.floor(Date.now() / 1000);
    return !payload?.exp || Number(payload.exp) >= now;
}

async function assertAuthenticated({ request, env }) {
    const authHeader = request.headers.get('authorization') || '';
    const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7).trim() : '';
    if (!token) return { ok: false, status: 401, error: 'Sessão inválida.' };

    // 1) Legacy custom JWT (generated by /api/login in older flows)
    const legacySecrets = [
        env.AUTH_JWT_SECRET,
        env.SUPABASE_SERVICE_ROLE_KEY,
        env.VITE_API_KEY,
    ].filter(Boolean);

    for (const secret of legacySecrets) {
        try {
            if (await verifyLegacyJwt(token, secret)) {
                return { ok: true };
            }
        } catch {
            // try next strategy
        }
    }

    // 2) Supabase access token
    const supabaseUrl = env.VITE_SUPABASE_URL;
    const serviceRoleKey = env.SUPABASE_SERVICE_ROLE_KEY;
    if (supabaseUrl && serviceRoleKey) {
        try {
            const admin = createClient(supabaseUrl, serviceRoleKey, {
                auth: { persistSession: false, autoRefreshToken: false },
            });
            const { data, error } = await admin.auth.getUser(token);
            if (!error && data?.user?.id) return { ok: true };
        } catch {
            // fall through
        }
    }

    return { ok: false, status: 401, error: 'Sessão inválida.' };
}

function buildEvolutionUrl(baseUrl, path = '', search = '') {
    const cleanBase = String(baseUrl || '').trim().replace(/\/+$/, '');
    const cleanPath = String(path || '').trim().replace(/^\/+/, '');
    // Backward compatibility: some old clients sent comma-separated path chunks.
    const normalizedPath = cleanPath.includes('/') ? cleanPath : cleanPath.replace(/,+/g, '/');
    const suffix = normalizedPath ? `/${normalizedPath}` : '';
    return `${cleanBase}${suffix}${search || ''}`;
}

export async function onRequest(context) {
    const { request, env } = context;

    if (request.method === 'OPTIONS') return json({ ok: true });

    try {
        const auth = await assertAuthenticated({ request, env });
        if (!auth.ok) return json({ error: auth.error }, auth.status);

        const evolutionUrl = getEnvOrThrow(env, ['EVOLUTION_API_URL', 'VITE_API_URL']);
        const evolutionKey = getEnvOrThrow(env, ['EVOLUTION_API_KEY', 'VITE_API_KEY']);
        const url = new URL(request.url);
        const path = String(url.searchParams.get('path') || '').trim();
        if (!path) return json({ error: 'Parâmetro path é obrigatório.' }, 400);

        const passthroughSearch = new URLSearchParams(url.searchParams);
        passthroughSearch.delete('path');
        const qs = passthroughSearch.toString();
        const upstreamUrl = buildEvolutionUrl(evolutionUrl, path, qs ? `?${qs}` : '');

        const headers = new Headers();
        headers.set('apikey', evolutionKey);
        const contentType = request.headers.get('content-type');
        if (contentType) headers.set('content-type', contentType);

        const isBodyMethod = !['GET', 'HEAD'].includes(request.method.toUpperCase());
        const body = isBodyMethod ? await request.arrayBuffer() : undefined;

        const upstreamRes = await fetch(upstreamUrl, {
            method: request.method,
            headers,
            body,
        });

        const upstreamContentType = upstreamRes.headers.get('content-type') || '';
        const raw = await upstreamRes.arrayBuffer();

        return new Response(raw, {
            status: upstreamRes.status,
            headers: {
                'Content-Type': upstreamContentType || 'application/json',
                'Access-Control-Allow-Origin': '*',
            },
        });
    } catch (error) {
        return json({ error: error?.message || 'Falha no proxy Evolution.' }, 500);
    }
}
